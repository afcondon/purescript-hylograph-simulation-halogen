// Generated by purs version 0.15.15
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Show from "../Data.Show/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var stateFinalRing = function (pos) {
    return function (gap) {
        return {
            cx: pos.cx,
            cy: pos.cy,
            rx: max(0.0)(pos.rx - gap),
            ry: max(0.0)(pos.ry - gap)
        };
    };
};
var stateEllipse = function (pos) {
    return {
        cx: pos.cx,
        cy: pos.cy,
        rx: pos.rx,
        ry: pos.ry
    };
};
var selfLoopPathD = function (path) {
    var dy = path.controlY - path.startY;
    var dx = path.controlX - path.startX;
    var radius = Data_Number.sqrt(dx * dx + dy * dy) * 0.8;
    return "M " + (show(path.startX) + (" " + (show(path.startY) + (" A " + (show(radius) + (" " + (show(radius) + (" 0" + (" 1" + (" 1" + (" " + (show(path.endX) + (" " + show(path.endY))))))))))))));
};
var transitionPathD = function (path) {
    if (path.isSelfLoop) {
        return selfLoopPathD(path);
    };
    return "M " + (show(path.startX) + (" " + (show(path.startY) + (" Q " + (show(path.controlX) + (" " + (show(path.controlY) + (" " + (show(path.endX) + (" " + show(path.endY)))))))))));
};
var initialArrowPathD = function (pos) {
    return function (len) {
        var endY = pos.y + len * Data_Number.sin(pos.angle);
        var endX = pos.x + len * Data_Number.cos(pos.angle);
        return "M " + (show(pos.x) + (" " + (show(pos.y) + (" L " + (show(endX) + (" " + show(endY)))))));
    };
};
var arrowheadPathD = function (tipX) {
    return function (tipY) {
        return function (angle) {
            return function (size) {
                var backAngle2 = angle + Data_Number.pi + 0.4;
                var backAngle1 = (angle + Data_Number.pi) - 0.4;
                var back2y = tipY + size * Data_Number.sin(backAngle2);
                var back2x = tipX + size * Data_Number.cos(backAngle2);
                var back1y = tipY + size * Data_Number.sin(backAngle1);
                var back1x = tipX + size * Data_Number.cos(backAngle1);
                return "M " + (show(tipX) + (" " + (show(tipY) + (" L " + (show(back1x) + (" " + (show(back1y) + (" L " + (show(back2x) + (" " + (show(back2y) + " Z")))))))))));
            };
        };
    };
};
export {
    transitionPathD,
    selfLoopPathD,
    arrowheadPathD,
    initialArrowPathD,
    stateEllipse,
    stateFinalRing
};
//# sourceMappingURL=index.js.map
