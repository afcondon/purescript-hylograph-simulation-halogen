// Generated by purs version 0.15.15
import * as $foreign from "./foreign.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Array_NonEmpty from "../Data.Array.NonEmpty/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as PSD3_Scale from "../PSD3.Scale/index.js";
var mapFlipped = /* #__PURE__ */ Data_Functor.mapFlipped(Data_Functor.functorArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var min1 = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var ticksWithLabels = function (count) {
    return function (specifier) {
        return function (scale) {
            var tickVals = PSD3_Scale.ticks(count)(scale);
            var formatter = PSD3_Scale.tickFormat(count)(specifier)(scale);
            return mapFlipped(tickVals)(function (t) {
                return {
                    position: PSD3_Scale.applyScale(scale)(t),
                    label: formatter(t)
                };
            });
        };
    };
};
var tickPositions = function (count) {
    return function (scale) {
        return mapFlipped(PSD3_Scale.ticks(count)(scale))(PSD3_Scale.applyScale(scale));
    };
};
var tickLabels = function (count) {
    return function (specifier) {
        return function (scale) {
            var tickVals = PSD3_Scale.ticks(count)(scale);
            var formatter = PSD3_Scale.tickFormat(count)(specifier)(scale);
            return mapFlipped(tickVals)(formatter);
        };
    };
};
var threshold = function (thresholds) {
    return function (values) {
        return function (value) {
            var idx = Data_Array.length(Data_Array.filter(function (v) {
                return v <= value;
            })(thresholds));
            var arr = Data_Array_NonEmpty.toArray(values);
            return Data_Maybe.fromMaybe(Data_Array_NonEmpty.head(values))(Data_Array.index(arr)(min(idx)(Data_Array.length(arr) - 1 | 0)));
        };
    };
};
var scaleMidpoint = function (scale) {
    return PSD3_Scale.applyScale(scale)(0.5);
};
var scaleExtent = function (scale) {
    var v1 = PSD3_Scale.applyScale(scale)(1.0);
    var v0 = PSD3_Scale.applyScale(scale)(0.0);
    return {
        min: min1(v0)(v1),
        max: max(v0)(v1)
    };
};
var scaleInRange = function (scale) {
    return function (value) {
        var ext = scaleExtent(scale);
        return value >= ext.min && value <= ext.max;
    };
};
var sampleWithDomain = function (n) {
    return function (scale) {
        var step = (function () {
            var $16 = n <= 1;
            if ($16) {
                return 0.0;
            };
            return 1.0 / Data_Int.toNumber(n - 1 | 0);
        })();
        var ts = mapFlipped(Data_Array.range(0)(n - 1 | 0))(function (i) {
            return Data_Int.toNumber(i) * step;
        });
        return mapFlipped(ts)(function (t) {
            return new Data_Tuple.Tuple(t, PSD3_Scale.applyScale(scale)(t));
        });
    };
};
var sampleRange = function (n) {
    return function (start) {
        return function (end) {
            return function (scale) {
                var step = (function () {
                    var $17 = n <= 1;
                    if ($17) {
                        return 0.0;
                    };
                    return (end - start) / Data_Int.toNumber(n - 1 | 0);
                })();
                var ts = mapFlipped(Data_Array.range(0)(n - 1 | 0))(function (i) {
                    return start + Data_Int.toNumber(i) * step;
                });
                return mapFlipped(ts)(PSD3_Scale.applyScale(scale));
            };
        };
    };
};
var sample = function (n) {
    return function (scale) {
        var step = (function () {
            var $18 = n <= 1;
            if ($18) {
                return 0.0;
            };
            return 1.0 / Data_Int.toNumber(n - 1 | 0);
        })();
        var ts = mapFlipped(Data_Array.range(0)(n - 1 | 0))(function (i) {
            return Data_Int.toNumber(i) * step;
        });
        return mapFlipped(ts)(PSD3_Scale.applyScale(scale));
    };
};
var roundModifier = /* #__PURE__ */ PSD3_Scale.round(true);
var reverseInterpolator = function (interp) {
    return function (t) {
        return interp(1.0 - t);
    };
};
var quantize = function (buckets) {
    return function (minVal) {
        return function (maxVal) {
            return function (value) {
                var normalized = (value - minVal) / (maxVal - minVal);
                var arr = Data_Array_NonEmpty.toArray(buckets);
                var n = Data_Array.length(arr);
                var idx = min(n - 1 | 0)(max1(0)(Data_Int.floor(normalized * Data_Int.toNumber(n))));
                return Data_Maybe.fromMaybe(Data_Array_NonEmpty.head(buckets))(Data_Array.index(arr)(idx));
            };
        };
    };
};
var normalize = function (minVal) {
    return function (maxVal) {
        return PSD3_Scale.domain([ minVal, maxVal ])(PSD3_Scale.range([ 0.0, 1.0 ])($foreign.createLinear));
    };
};
var niceModifier = PSD3_Scale.nice;
var cycleInterpolator = function (interp) {
    return function (t) {
        var t$prime = t - Data_Int.toNumber(Data_Int.floor(t));
        return interp((function () {
            var $19 = t$prime < 0.0;
            if ($19) {
                return t$prime + 1.0;
            };
            return t$prime;
        })());
    };
};
var combineModifiers = function (mods) {
    return function (scale) {
        return Data_Array.foldl(function (s) {
            return function (m) {
                return m(s);
            };
        })(scale)(mods);
    };
};
var clampModifier = /* #__PURE__ */ PSD3_Scale.clamp(true);
var clampInterpolator = function (interp) {
    return function (t) {
        return interp(max(0.0)(min1(1.0)(t)));
    };
};
var blendInterpolators = function (mix) {
    return function (i1) {
        return function (i2) {
            return function (t) {
                var $20 = t < mix;
                if ($20) {
                    return i1(t / mix);
                };
                return i2((t - mix) / (1.0 - mix));
            };
        };
    };
};
export {
    niceModifier,
    clampModifier,
    roundModifier,
    combineModifiers,
    sample,
    sampleRange,
    sampleWithDomain,
    tickPositions,
    tickLabels,
    ticksWithLabels,
    blendInterpolators,
    reverseInterpolator,
    clampInterpolator,
    cycleInterpolator,
    normalize,
    quantize,
    threshold,
    scaleExtent,
    scaleMidpoint,
    scaleInRange
};
//# sourceMappingURL=index.js.map
