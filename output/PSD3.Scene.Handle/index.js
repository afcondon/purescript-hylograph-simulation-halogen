// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Set from "../Data.Set/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
import * as Foreign_Object from "../Foreign.Object/index.js";
import * as PSD3_ForceEngine_Core from "../PSD3.ForceEngine.Core/index.js";
import * as PSD3_ForceEngine_Simulation from "../PSD3.ForceEngine.Simulation/index.js";
import * as PSD3_Scene_Engine from "../PSD3.Scene.Engine/index.js";
import * as PSD3_Scene_Types from "../PSD3.Scene.Types/index.js";
import * as PSD3_Simulation_Scene from "../PSD3.Simulation.Scene/index.js";
var fromFoldable = /* #__PURE__ */ Data_Set.fromFoldable(Data_Foldable.foldableArray)(Data_Ord.ordString);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray);
var toUnfoldable = /* #__PURE__ */ Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect.applicativeEffect);
var when = /* #__PURE__ */ Control_Applicative.when(Effect.applicativeEffect);
var fromFoldable1 = /* #__PURE__ */ Foreign_Object.fromFoldable(Data_Foldable.foldableArray);
var SceneHandle = function (x) {
    return x;
};
var transitionTo = function (scene) {
    return function (v) {
        return function __do() {
            var state = Effect_Ref.read(v)();
            PSD3_Scene_Engine.transitionTo(scene)(state.engine)();
            return PSD3_ForceEngine_Simulation.reheat(state.simulation)();
        };
    };
};
var showAllNodes = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        var nodes = PSD3_ForceEngine_Simulation.getNodes(state.simulation)();
        var allIds = fromFoldable(map(function (n) {
            return show(n.id);
        })(nodes));
        return Effect_Ref.modify_(function (v1) {
            return {
                allNodes: v1.allNodes,
                callbacks: v1.callbacks,
                engine: v1.engine,
                linksGroupId: v1.linksGroupId,
                nodesGroupId: v1.nodesGroupId,
                simulation: v1.simulation,
                visibleNodeIds: allIds
            };
        })(v)();
    };
};
var reinitializeForces = function (sim) {
    return function __do() {
        var nodes = Effect_Ref.read(sim.nodes)();
        var forces = Effect_Ref.read(sim.forces)();
        return for_(toUnfoldable(forces))(function (v) {
            return function __do() {
                PSD3_ForceEngine_Core.initializeForce(v.value1)(nodes)();
                return Data_Unit.unit;
            };
        })();
    };
};
var reheat = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_ForceEngine_Simulation.reheat(state.simulation)();
    };
};
var onTick = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        var wasTransitioning = PSD3_Scene_Engine.isTransitioning(state.engine)();
        var stillTransitioning = PSD3_Scene_Engine.tick(state.engine)();
        when(wasTransitioning && !stillTransitioning)(state.callbacks.onTransitionComplete)();
        return stillTransitioning;
    };
};
var isTransitioning = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_Scene_Engine.isTransitioning(state.engine)();
    };
};
var getTransitionProgress = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_Scene_Engine.getTransitionProgress(state.engine)();
    };
};
var getSimulation = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return state.simulation;
    };
};
var getCurrentScene = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_Scene_Engine.getCurrentScene(state.engine)();
    };
};
var getAllNodes = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_ForceEngine_Simulation.getNodes(state.simulation)();
    };
};
var filterNodes = function (predicate) {
    return function (v) {
        return function __do() {
            var state = Effect_Ref.read(v)();
            var nodes = PSD3_ForceEngine_Simulation.getNodes(state.simulation)();
            var visibleIds = fromFoldable(Data_Array.mapMaybe(function (n) {
                var $46 = predicate(n);
                if ($46) {
                    return new Data_Maybe.Just(show(n.id));
                };
                return Data_Maybe.Nothing.value;
            })(nodes));
            return Effect_Ref.modify_(function (v1) {
                return {
                    allNodes: v1.allNodes,
                    callbacks: v1.callbacks,
                    engine: v1.engine,
                    linksGroupId: v1.linksGroupId,
                    nodesGroupId: v1.nodesGroupId,
                    simulation: v1.simulation,
                    visibleNodeIds: visibleIds
                };
            })(v)();
        };
    };
};
var destroy = function (v) {
    return function __do() {
        var state = Effect_Ref.read(v)();
        return PSD3_ForceEngine_Simulation.stop(state.simulation)();
    };
};
var capturePositions = function (nodes) {
    return fromFoldable1(map(function (n) {
        return new Data_Tuple.Tuple(show(n.id), {
            x: n.x,
            y: n.y
        });
    })(nodes));
};
var applyRulesInPlace = function (rules) {
    return function (sim) {
        var v = PSD3_Simulation_Scene.applyRulesInPlace_(rules)(sim.nodes);
        return pure(Data_Unit.unit);
    };
};
var mkAdapter = function (sim) {
    return {
        getNodes: PSD3_ForceEngine_Simulation.getNodes(sim),
        capturePositions: capturePositions,
        interpolatePositions: function (start) {
            return function (target) {
                return function (progress) {
                    return PSD3_ForceEngine_Simulation.interpolatePositionsInPlace(start)(target)(progress)(sim);
                };
            };
        },
        updatePositions: function (positions) {
            return PSD3_ForceEngine_Simulation.updatePositionsInPlace(positions)(sim);
        },
        applyRulesInPlace: function (rules) {
            return applyRulesInPlace(rules)(sim);
        },
        reinitializeForces: reinitializeForces(sim),
        reheat: PSD3_ForceEngine_Simulation.reheat(sim)
    };
};
var create = function (config) {
    return function (callbacks) {
        return function (nodes) {
            return function (links) {
                return function (renderFn) {
                    return function __do() {
                        var simulation = PSD3_ForceEngine_Simulation.create(PSD3_ForceEngine_Simulation.defaultConfig)();
                        PSD3_ForceEngine_Simulation.setNodes(nodes)(simulation)();
                        PSD3_ForceEngine_Simulation.setLinks(links)(simulation)();
                        var tickHandler = function __do() {
                            var currentNodes = PSD3_ForceEngine_Simulation.getNodes(simulation)();
                            return renderFn(currentNodes)();
                        };
                        PSD3_ForceEngine_Simulation.onTick(tickHandler)(simulation)();
                        var adapter = mkAdapter(simulation);
                        var engine = PSD3_Scene_Engine.createEngine(adapter)();
                        var nodeIds = fromFoldable(map(function (n) {
                            return show(n.id);
                        })(nodes));
                        var stateRef = Effect_Ref["new"]({
                            simulation: simulation,
                            engine: engine,
                            callbacks: callbacks,
                            allNodes: nodes,
                            visibleNodeIds: nodeIds,
                            nodesGroupId: config.nodesGroupId,
                            linksGroupId: config.linksGroupId
                        })();
                        return stateRef;
                    };
                };
            };
        };
    };
};
var transformNodes = function (transform) {
    return function (v) {
        return function __do() {
            var state = Effect_Ref.read(v)();
            var rule = {
                name: "transform",
                select: Data_Function["const"](true),
                apply: transform
            };
            applyRulesInPlace([ rule ])(state.simulation)();
            reinitializeForces(state.simulation)();
            return PSD3_ForceEngine_Simulation.reheat(state.simulation)();
        };
    };
};
export {
    create,
    destroy,
    transitionTo,
    isTransitioning,
    getTransitionProgress,
    getCurrentScene,
    getAllNodes,
    filterNodes,
    showAllNodes,
    transformNodes,
    onTick,
    getSimulation,
    reheat
};
export {
    Physics,
    Static
} from "../PSD3.Scene.Types/index.js";
//# sourceMappingURL=index.js.map
