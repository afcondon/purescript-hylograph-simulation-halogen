{"comments":null,"declarations":[{"children":[],"comments":null,"info":{"dataDeclType":"data","declType":"data","roles":[],"typeArguments":[]},"kind":null,"sourceSpan":{"end":[28,38],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[28,1]},"title":"TreeJson_"},{"children":[],"comments":null,"info":{"dataDeclType":"data","declType":"data","roles":[],"typeArguments":[]},"kind":null,"sourceSpan":{"end":[49,42],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[49,1]},"title":"TreeLayoutFn_"},{"children":[],"comments":"D3 tree node (result of d3.hierarchy() and layout functions)\nParameterized by datum type\n","info":{"dataDeclType":"data","declType":"data","roles":["Nominal"],"typeArguments":[["t0",null]]},"kind":null,"sourceSpan":{"end":[33,48],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[33,1]},"title":"D3_TreeNode"},{"children":[{"comments":null,"info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":{"end":[35,27],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[35,17]},"title":"TidyTree"},{"comments":null,"info":{"arguments":[],"declType":"dataConstructor"},"sourceSpan":{"end":[35,40],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[35,28]},"title":"Dendrogram"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Eq"],"Eq"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeType"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[36,42],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[36,1]},"title":"eqTreeType"},{"comments":null,"info":{"declType":"instance","dependencies":[],"type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Show"],"Show"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeType"],"tag":"TypeConstructor"}],"tag":"TypeApp"}},"sourceSpan":{"end":[39,33],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[37,1]},"title":"showTreeType"}],"comments":null,"info":{"dataDeclType":"data","declType":"data","roles":[],"typeArguments":[]},"kind":null,"sourceSpan":{"end":[35,40],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[35,1]},"title":"TreeType"},{"children":[],"comments":null,"info":{"arguments":[],"declType":"typeSynonym","type":{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["json",{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeJson_"],"tag":"TypeConstructor"},{"annotation":[],"contents":["treeType",{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeType"],"tag":"TypeConstructor"},{"annotation":[],"contents":["treeLayout",{"annotation":[],"contents":[["Data","Graph","Layout"],"TreeLayout"],"tag":"TypeConstructor"},{"annotation":[],"contents":["treeLayoutFn",{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeLayoutFn_"],"tag":"TypeConstructor"},{"annotation":[],"contents":["svgConfig",{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["width",{"annotation":[],"contents":[["Prim"],"Number"],"tag":"TypeConstructor"},{"annotation":[],"contents":["height",{"annotation":[],"contents":[["Prim"],"Number"],"tag":"TypeConstructor"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"}},"kind":null,"sourceSpan":{"end":[47,2],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[41,1]},"title":"TreeModel"},{"children":[],"comments":"Convert a Tree of NodeIDs to D3 TreeJson format using a lookup map\n\nThis function is useful when you have a Tree structure where nodes\ncontain only IDs, and you need to look up the full node data from a Map.\n\nExample:\n```purescript\nlet tree = mkTree \"root\" $ L.fromFoldable [mkTree \"child1\" Nil, mkTree \"child2\" Nil]\nlet dataMap = M.fromFoldable [\n  Tuple \"root\" {name: \"Root\", value: 100},\n  Tuple \"child1\" {name: \"Child 1\", value: 50}\n]\nlet d3Tree = makeD3TreeJSONFromTreeID tree dataMap\n```\n\nNote: If a node ID is not found in the map, an empty tree node is created.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"d","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tree"],"Tree"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["PSD3","Data","Node"],"NodeID"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Map","Internal"],"Map"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["PSD3","Data","Node"],"NodeID"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeJson_"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[67,81],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[67,1]},"title":"makeD3TreeJSONFromTreeID"},{"children":[],"comments":"Convert a PureScript Tree directly to D3 TreeJson format\n\nThis is the simplest conversion - each node already contains its data,\nno lookup required.\n\nExample:\n```purescript\nlet tree = mkTree {name: \"Root\", value: 100} $ L.fromFoldable\n             [ mkTree {name: \"Child 1\", value: 50} Nil\n             , mkTree {name: \"Child 2\", value: 30} Nil\n             ]\nlet d3Tree = treeToD3Tree tree\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"d","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tree"],"Tree"],"tag":"TypeConstructor"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[["PSD3","Data","Tree"],"TreeJson_"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[92,46],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[92,1]},"title":"treeToD3Tree"},{"children":[],"comments":"Build a Tree from an array of nodes with parent pointers\n\nThis function constructs a tree from a flat array where each node\nknows its parent ID. Useful for loading hierarchical data from databases\nor JSON where parent-child relationships are encoded as references.\n\nExample:\n```purescript\nlet nodes = [\n  {id: \"1\", parentId: Nothing, name: \"Root\"},\n  {id: \"2\", parentId: Just \"1\", name: \"Child 1\"},\n  {id: \"3\", parentId: Just \"1\", name: \"Child 2\"}\n]\nlet tree = arrayToTree {\n  nodes: nodes,\n  getId: _.id,\n  getParentId: _.parentId\n}\n```\n\nReturns Left with error message if:\n- No root node found (node with Nothing parent)\n- Multiple root nodes found\n- Circular references detected\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"d","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["nodes",{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":["getId",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["PSD3","Data","Node"],"NodeID"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":["getParentId",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["PSD3","Data","Node"],"NodeID"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Either"],"Either"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tree"],"Tree"],"tag":"TypeConstructor"},{"annotation":[],"contents":"d","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[129,25],"name":"../purescript-psd3-selection/src/PSD3/Data/Tree.purs","start":[124,1]},"title":"arrayToTree"}],"name":"PSD3.Data.Tree","reExports":[]}