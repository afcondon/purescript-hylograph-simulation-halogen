// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Map from "../Data.Map/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Set from "../Data.Set/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Map_Internal.functorMap);
var toUnfoldable = /* #__PURE__ */ Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray);
var clamp = /* #__PURE__ */ Data_Ord.clamp(Data_Ord.ordNumber);
var withEasing = function (ease) {
    return function (f) {
        return function (t) {
            return f(ease(t));
        };
    };
};
var ticksForDuration = function (milliseconds) {
    var ticks = Data_Int.toNumber(milliseconds) / 16.67;
    return 1.0 / ticks;
};
var tickTransitions = function (delta) {
    return function (transitions) {
        var advanced = map(function (t) {
            return {
                item: t.item,
                progress: min(1.0)(t.progress + delta)
            };
        })(transitions);
        var completed = map(function (v) {
            return v.item;
        })(Data_Array.filter(function (t) {
            return t.progress >= 1.0;
        })(advanced));
        var active = Data_Array.filter(function (t) {
            return t.progress < 1.0;
        })(advanced);
        return {
            active: active,
            completed: completed
        };
    };
};
var tickProgressMap = function (dictOrd) {
    var filter = Data_Map_Internal.filter(dictOrd);
    return function (delta) {
        return function (progressMap) {
            var advanced = map1(function (p) {
                return min(1.0)(p + delta);
            })(progressMap);
            var completed = toUnfoldable(Data_Map.keys(filter(function (p) {
                return p >= 1.0;
            })(advanced)));
            var active = filter(function (p) {
                return p < 1.0;
            })(advanced);
            return {
                active: active,
                completed: completed
            };
        };
    };
};
var startTransitionsFrom = function (initial) {
    return map(function (item) {
        return {
            item: item,
            progress: initial
        };
    });
};
var startTransitions = /* #__PURE__ */ map(function (item) {
    return {
        item: item,
        progress: 0.0
    };
});
var startProgressFrom = function (dictOrd) {
    var insert = Data_Map_Internal.insert(dictOrd);
    return function (initial) {
        return function (keys) {
            return function (existing) {
                return Data_Array.foldl(function (m) {
                    return function (k) {
                        return insert(k)(initial)(m);
                    };
                })(existing)(keys);
            };
        };
    };
};
var startProgress = function (dictOrd) {
    var insert = Data_Map_Internal.insert(dictOrd);
    return function (keys) {
        return function (existing) {
            return Data_Array.foldl(function (m) {
                return function (k) {
                    return insert(k)(0.0)(m);
                };
            })(existing)(keys);
        };
    };
};
var linear = function (t) {
    return t;
};
var lerp = function (start) {
    return function (end) {
        return function (t) {
            return start + (end - start) * t;
        };
    };
};
var lerpClamped = function (start) {
    return function (end) {
        return function (t) {
            return lerp(start)(end)(clamp(0.0)(1.0)(t));
        };
    };
};
var lerpInt = function (start) {
    return function (end) {
        return function (t) {
            return Data_Int.round(lerp(Data_Int.toNumber(start))(Data_Int.toNumber(end))(t));
        };
    };
};
var easeOutQuad = function (t) {
    return 1.0 - (1.0 - t) * (1.0 - t);
};
var easeOutCubic = function (t) {
    return 1.0 - (1.0 - t) * (1.0 - t) * (1.0 - t);
};
var easeOut = easeOutQuad;
var easeInQuad = function (t) {
    return t * t;
};
var easeInOutQuad = function (t) {
    var $20 = t < 0.5;
    if ($20) {
        return 2.0 * t * t;
    };
    return 1.0 - ((-2.0 * t + 2.0) * (-2.0 * t + 2.0)) / 2.0;
};
var easeInOutCubic = function (t) {
    var $21 = t < 0.5;
    if ($21) {
        return 4.0 * t * t * t;
    };
    return 1.0 - ((-2.0 * t + 2.0) * (-2.0 * t + 2.0) * (-2.0 * t + 2.0)) / 2.0;
};
var easeInOut = easeInOutQuad;
var easeInCubic = function (t) {
    return t * t * t;
};
var easeIn = easeInQuad;
export {
    tickProgressMap,
    startProgress,
    startProgressFrom,
    tickTransitions,
    startTransitions,
    startTransitionsFrom,
    lerp,
    lerpClamped,
    lerpInt,
    linear,
    easeIn,
    easeOut,
    easeInOut,
    easeInQuad,
    easeOutQuad,
    easeInOutQuad,
    easeInCubic,
    easeOutCubic,
    easeInOutCubic,
    withEasing,
    ticksForDuration
};
//# sourceMappingURL=index.js.map
