// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_HeytingAlgebra from "../Data.HeytingAlgebra/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as PSD3_Transition_Easing from "../PSD3.Transition.Easing/index.js";
import * as PSD3_Transition_Tick from "../PSD3.Transition.Tick/index.js";
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var maximum = /* #__PURE__ */ Data_Foldable.maximum(Data_Ord.ordNumber)(Data_Foldable.foldableArray);
var all = /* #__PURE__ */ Data_Foldable.all(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean);
var TransitionGroup = function (x) {
    return x;
};
var IndexedTransitionGroup = function (x) {
    return x;
};
var withDelay = function (delay) {
    return function (spec) {
        return {
            from: spec.from,
            to: spec.to,
            interpolate: spec.interpolate,
            config: {
                duration: spec.config.duration,
                easing: spec.config.easing,
                delay: delay
            }
        };
    };
};
var transitionWith = function (interpolate) {
    return function (values) {
        return function (config) {
            return {
                from: values.from,
                to: values.to,
                interpolate: interpolate,
                config: config
            };
        };
    };
};
var transition = function (values) {
    return function (opts) {
        return {
            from: values.from,
            to: values.to,
            interpolate: PSD3_Transition_Tick.lerp,
            config: {
                duration: opts.duration,
                easing: opts.easing,
                delay: 0.0
            }
        };
    };
};
var tickBy = function (delta) {
    return function (state) {
        var newElapsed = state.elapsed + delta;
        var effectiveElapsed = max(0.0)(newElapsed - state.spec.config.delay);
        var rawProgress = effectiveElapsed / state.spec.config.duration;
        var easingFn = PSD3_Transition_Easing.toFunction(state.spec.config.easing);
        var clampedProgress = min(1.0)(max(0.0)(rawProgress));
        var easedProgress = easingFn(clampedProgress);
        var newValue = state.spec.interpolate(state.spec.from)(state.spec.to)(easedProgress);
        return {
            spec: state.spec,
            elapsed: newElapsed,
            current: newValue
        };
    };
};
var tick = function (delta) {
    return function (state) {
        return tickBy(delta)(state);
    };
};
var start = function (spec) {
    return {
        spec: spec,
        elapsed: 0.0,
        current: spec.from
    };
};
var staggeredSpecs = function (count) {
    return function (staggerDelay) {
        return function (baseSpec) {
            var mkSpec = function (i) {
                var indexDelay = Data_Int.toNumber(i) * staggerDelay;
                return withDelay(baseSpec.config.delay + indexDelay)(baseSpec);
            };
            return map(mkSpec)(Data_Array.range(0)(count - 1 | 0));
        };
    };
};
var staggeredGroupIndexed = function (valuePairs) {
    return function (staggerDelay) {
        return function (opts) {
            var mkTransition = function (i) {
                return function (values) {
                    var spec = transition(values)(opts);
                    var indexDelay = Data_Int.toNumber(i) * staggerDelay;
                    var delayedSpec = withDelay(indexDelay)(spec);
                    return {
                        index: i,
                        state: start(delayedSpec)
                    };
                };
            };
            return {
                transitions: Data_Array.mapWithIndex(mkTransition)(valuePairs)
            };
        };
    };
};
var staggeredGroup = function (valuePairs) {
    return function (staggerDelay) {
        return function (opts) {
            var mkTransition = function (i) {
                return function (values) {
                    var spec = transition(values)(opts);
                    var indexDelay = Data_Int.toNumber(i) * staggerDelay;
                    var delayedSpec = withDelay(indexDelay)(spec);
                    return start(delayedSpec);
                };
            };
            return {
                transitions: Data_Array.mapWithIndex(mkTransition)(valuePairs)
            };
        };
    };
};
var remaining = function (state) {
    return max(0.0)((state.spec.config.duration + state.spec.config.delay) - state.elapsed);
};
var isComplete = function (state) {
    return state.elapsed >= state.spec.config.duration + state.spec.config.delay;
};
var indexedGroupTick = function (delta) {
    return function (v) {
        var tickIndexed = function (t) {
            return {
                index: t.index,
                state: tick(delta)(t.state)
            };
        };
        return {
            transitions: map(tickIndexed)(v.transitions)
        };
    };
};
var indexedGroupRemaining = function (v) {
    return Data_Maybe.fromMaybe(0.0)(maximum(map(function (t) {
        return remaining(t.state);
    })(v.transitions)));
};
var indexedGroupComplete = function (v) {
    return all(function (t) {
        return isComplete(t.state);
    })(v.transitions);
};
var groupTick = function (delta) {
    return function (v) {
        return {
            transitions: map(tick(delta))(v.transitions)
        };
    };
};
var groupRemaining = function (v) {
    return Data_Maybe.fromMaybe(0.0)(maximum(map(remaining)(v.transitions)));
};
var groupComplete = function (v) {
    return all(isComplete)(v.transitions);
};
var group = function (specs) {
    return {
        transitions: map(start)(specs)
    };
};
var defaultConfig = /* #__PURE__ */ (function () {
    return {
        duration: 300.0,
        easing: PSD3_Transition_Easing.QuadOut.value,
        delay: 0.0
    };
})();
var currentValue = function (v) {
    return v.current;
};
var groupValues = function (v) {
    return map(currentValue)(v.transitions);
};
var indexedValues = function (v) {
    return map(function (t) {
        return {
            index: t.index,
            value: currentValue(t.state)
        };
    })(v.transitions);
};
var currentProgress = function (state) {
    var effectiveElapsed = max(0.0)(state.elapsed - state.spec.config.delay);
    var raw = effectiveElapsed / state.spec.config.duration;
    return min(1.0)(max(0.0)(raw));
};
export {
    transition,
    transitionWith,
    withDelay,
    start,
    tick,
    tickBy,
    currentValue,
    currentProgress,
    isComplete,
    remaining,
    group,
    groupTick,
    groupValues,
    groupComplete,
    groupRemaining,
    staggeredGroup,
    staggeredSpecs,
    staggeredGroupIndexed,
    indexedGroupTick,
    indexedValues,
    indexedGroupComplete,
    indexedGroupRemaining,
    defaultConfig
};
//# sourceMappingURL=index.js.map
