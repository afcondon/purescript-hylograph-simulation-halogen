// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Map from "../Data.Map/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Set from "../Data.Set/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
import * as PSD3_Kernel_D3_Core from "../PSD3.Kernel.D3.Core/index.js";
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var $$delete = /* #__PURE__ */ Data_Map_Internal["delete"](Data_Ord.ordString);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect.applicativeEffect);
var fromFoldable = /* #__PURE__ */ Data_Set.fromFoldable(Data_Foldable.foldableArray);
var fromFoldable1 = /* #__PURE__ */ fromFoldable(Data_Ord.ordInt);
var member = /* #__PURE__ */ Data_Set.member(Data_Ord.ordInt);
var fromFoldable2 = /* #__PURE__ */ Data_Map_Internal.fromFoldable(Data_Ord.ordInt)(Data_Foldable.foldableArray);
var lookup = /* #__PURE__ */ Data_Map_Internal.lookup(Data_Ord.ordInt);
var ordTuple = /* #__PURE__ */ Data_Tuple.ordTuple(Data_Ord.ordInt)(Data_Ord.ordInt);
var fromFoldable3 = /* #__PURE__ */ fromFoldable(ordTuple);
var difference = /* #__PURE__ */ Data_Set.difference(ordTuple);
var member1 = /* #__PURE__ */ Data_Set.member(ordTuple);
var intersection = /* #__PURE__ */ Data_Set.intersection(ordTuple);
var fromFoldable4 = /* #__PURE__ */ fromFoldable(Data_Ord.ordString);
var fromFoldable5 = /* #__PURE__ */ Data_Set.fromFoldable(Data_Set.foldableSet)(Data_Ord.ordString);
var difference1 = /* #__PURE__ */ Data_Set.difference(Data_Ord.ordString);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray);
var toUnfoldable = /* #__PURE__ */ Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray);
var insert = /* #__PURE__ */ Data_Map_Internal.insert(Data_Ord.ordString);
var Static = /* #__PURE__ */ (function () {
    function Static(value0) {
        this.value0 = value0;
    };
    Static.create = function (value0) {
        return new Static(value0);
    };
    return Static;
})();
var Dynamic = /* #__PURE__ */ (function () {
    function Dynamic(value0) {
        this.value0 = value0;
    };
    Dynamic.create = function (value0) {
        return new Dynamic(value0);
    };
    return Dynamic;
})();
var ForceManyBody = /* #__PURE__ */ (function () {
    function ForceManyBody() {

    };
    ForceManyBody.value = new ForceManyBody();
    return ForceManyBody;
})();
var ForceCollide = /* #__PURE__ */ (function () {
    function ForceCollide() {

    };
    ForceCollide.value = new ForceCollide();
    return ForceCollide;
})();
var ForceLink = /* #__PURE__ */ (function () {
    function ForceLink() {

    };
    ForceLink.value = new ForceLink();
    return ForceLink;
})();
var ForceCenter = /* #__PURE__ */ (function () {
    function ForceCenter() {

    };
    ForceCenter.value = new ForceCenter();
    return ForceCenter;
})();
var ForcePositionX = /* #__PURE__ */ (function () {
    function ForcePositionX() {

    };
    ForcePositionX.value = new ForcePositionX();
    return ForcePositionX;
})();
var ForcePositionY = /* #__PURE__ */ (function () {
    function ForcePositionY() {

    };
    ForcePositionY.value = new ForcePositionY();
    return ForcePositionY;
})();
var ForceRadial = /* #__PURE__ */ (function () {
    function ForceRadial() {

    };
    ForceRadial.value = new ForceRadial();
    return ForceRadial;
})();
var withY = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            y: v
        };
    };
};
var withX = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            x: v
        };
    };
};
var withVelocityDecay = function (v) {
    return function (s) {
        return {
            name: s.name,
            forces: s.forces,
            params: {
                alpha: s.params.alpha,
                alphaMin: s.params.alphaMin,
                alphaDecay: s.params.alphaDecay,
                alphaTarget: s.params.alphaTarget,
                velocityDecay: v
            }
        };
    };
};
var withTheta = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            theta: v
        };
    };
};
var withStrength = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            strength: v
        };
    };
};
var withRadius = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            radius: v
        };
    };
};
var withIterations = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            filter: fc.filter,
            iterations: v
        };
    };
};
var withFilter = function (pred) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: new Data_Maybe.Just(pred)
        };
    };
};
var withDistanceMin = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            distanceMin: v
        };
    };
};
var withDistanceMax = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            distance: fc.distance,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            iterations: fc.iterations,
            filter: fc.filter,
            distanceMax: v
        };
    };
};
var withDistance = function (v) {
    return function (fc) {
        return {
            name: fc.name,
            forceType: fc.forceType,
            strength: fc.strength,
            radius: fc.radius,
            x: fc.x,
            y: fc.y,
            theta: fc.theta,
            distanceMin: fc.distanceMin,
            distanceMax: fc.distanceMax,
            iterations: fc.iterations,
            filter: fc.filter,
            distance: v
        };
    };
};
var withAlphaTarget = function (v) {
    return function (s) {
        return {
            name: s.name,
            forces: s.forces,
            params: {
                alpha: s.params.alpha,
                alphaMin: s.params.alphaMin,
                alphaDecay: s.params.alphaDecay,
                velocityDecay: s.params.velocityDecay,
                alphaTarget: v
            }
        };
    };
};
var withAlphaMin = function (v) {
    return function (s) {
        return {
            name: s.name,
            forces: s.forces,
            params: {
                alpha: s.params.alpha,
                alphaDecay: s.params.alphaDecay,
                alphaTarget: s.params.alphaTarget,
                velocityDecay: s.params.velocityDecay,
                alphaMin: v
            }
        };
    };
};
var withAlphaDecay = function (v) {
    return function (s) {
        return {
            name: s.name,
            forces: s.forces,
            params: {
                alpha: s.params.alpha,
                alphaMin: s.params.alphaMin,
                alphaTarget: s.params.alphaTarget,
                velocityDecay: s.params.velocityDecay,
                alphaDecay: v
            }
        };
    };
};
var withAlpha = function (v) {
    return function (s) {
        return {
            name: s.name,
            forces: s.forces,
            params: {
                alphaMin: s.params.alphaMin,
                alphaDecay: s.params.alphaDecay,
                alphaTarget: s.params.alphaTarget,
                velocityDecay: s.params.velocityDecay,
                alpha: v
            }
        };
    };
};
var valueToNumber = function (v) {
    if (v instanceof Static) {
        return v.value0;
    };
    if (v instanceof Dynamic) {
        return 0.0;
    };
    throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 121, column 1 - line 121, column 58): " + [ v.constructor.name ]);
};
var updateForce = function (fc) {
    return function (s) {
        var replace = function (existing) {
            var $73 = existing.name === fc.name;
            if ($73) {
                return fc;
            };
            return existing;
        };
        return {
            name: s.name,
            params: s.params,
            forces: map(replace)(s.forces)
        };
    };
};
var $$static = /* #__PURE__ */ (function () {
    return Static.create;
})();
var setupWithParams = function (name) {
    return function (forces) {
        return function (params) {
            return {
                name: name,
                forces: forces,
                params: params
            };
        };
    };
};
var removeForceFromSim = function (name) {
    return function (sim) {
        return Effect_Ref.modify_($$delete(name))(sim.forces);
    };
};
var removeForce = function (name) {
    return function (s) {
        return {
            name: s.name,
            params: s.params,
            forces: Data_Array.filter(function (fc) {
                return fc.name !== name;
            })(s.forces)
        };
    };
};
var mergeSimulationState = function (current) {
    return function (desired) {
        var $74 = {};
        for (var $75 in desired) {
            if ({}.hasOwnProperty.call(desired, $75)) {
                $74[$75] = desired[$75];
            };
        };
        $74.x = current.x;
        $74.y = current.y;
        $74.vx = current.vx;
        $74.vy = current.vy;
        $74.fx = current.fx;
        $74.fy = current.fy;
        return $74;
    };
};
var getParams = function (s) {
    return s.params;
};
var getForces = function (s) {
    return s.forces;
};
var forceName = function (fc) {
    return fc.name;
};
var eqForceType = {
    eq: function (x) {
        return function (y) {
            if (x instanceof ForceManyBody && y instanceof ForceManyBody) {
                return true;
            };
            if (x instanceof ForceCollide && y instanceof ForceCollide) {
                return true;
            };
            if (x instanceof ForceLink && y instanceof ForceLink) {
                return true;
            };
            if (x instanceof ForceCenter && y instanceof ForceCenter) {
                return true;
            };
            if (x instanceof ForcePositionX && y instanceof ForcePositionX) {
                return true;
            };
            if (x instanceof ForcePositionY && y instanceof ForcePositionY) {
                return true;
            };
            if (x instanceof ForceRadial && y instanceof ForceRadial) {
                return true;
            };
            return false;
        };
    }
};
var dynamic = /* #__PURE__ */ (function () {
    return Dynamic.create;
})();
var defaultParams = {
    alpha: 1.0,
    alphaMin: 1.0e-3,
    alphaDecay: 1.0e-2,
    alphaTarget: 0.0,
    velocityDecay: 0.4
};
var setup = function (name) {
    return function (forces) {
        return {
            name: name,
            forces: forces,
            params: defaultParams
        };
    };
};
var defaultForceConfig = function (name) {
    return function (forceType) {
        return {
            name: name,
            forceType: forceType,
            strength: new Static(1.0),
            radius: new Static(1.0),
            x: new Static(0.0),
            y: new Static(0.0),
            distance: new Static(30.0),
            theta: 0.9,
            distanceMin: 1.0,
            distanceMax: 1.0e10,
            iterations: 1,
            filter: Data_Maybe.Nothing.value
        };
    };
};
var link = function (name) {
    return defaultForceConfig(name)(ForceLink.value);
};
var manyBody = function (name) {
    var v = defaultForceConfig(name)(ForceManyBody.value);
    return {
        name: v.name,
        forceType: v.forceType,
        radius: v.radius,
        x: v.x,
        y: v.y,
        distance: v.distance,
        theta: v.theta,
        distanceMin: v.distanceMin,
        distanceMax: v.distanceMax,
        iterations: v.iterations,
        filter: v.filter,
        strength: new Static(-30.0)
    };
};
var positionX = function (name) {
    var v = defaultForceConfig(name)(ForcePositionX.value);
    return {
        name: v.name,
        forceType: v.forceType,
        radius: v.radius,
        y: v.y,
        distance: v.distance,
        theta: v.theta,
        distanceMin: v.distanceMin,
        distanceMax: v.distanceMax,
        iterations: v.iterations,
        filter: v.filter,
        strength: new Static(0.1),
        x: new Static(0.0)
    };
};
var positionY = function (name) {
    var v = defaultForceConfig(name)(ForcePositionY.value);
    return {
        name: v.name,
        forceType: v.forceType,
        radius: v.radius,
        x: v.x,
        distance: v.distance,
        theta: v.theta,
        distanceMin: v.distanceMin,
        distanceMax: v.distanceMax,
        iterations: v.iterations,
        filter: v.filter,
        strength: new Static(0.1),
        y: new Static(0.0)
    };
};
var radial = function (name) {
    var v = defaultForceConfig(name)(ForceRadial.value);
    return {
        name: v.name,
        forceType: v.forceType,
        x: v.x,
        y: v.y,
        distance: v.distance,
        theta: v.theta,
        distanceMin: v.distanceMin,
        distanceMax: v.distanceMax,
        iterations: v.iterations,
        filter: v.filter,
        strength: new Static(0.1),
        radius: new Static(100.0)
    };
};
var createForceHandle = function (fc) {
    return pure((function () {
        if (fc.forceType instanceof ForceManyBody) {
            if (fc.filter instanceof Data_Maybe.Just) {
                return PSD3_Kernel_D3_Core.createManyBodyFiltered({
                    strength: valueToNumber(fc.strength),
                    theta: fc.theta,
                    distanceMin: fc.distanceMin,
                    distanceMax: fc.distanceMax,
                    filter: fc.filter.value0
                });
            };
            if (fc.filter instanceof Data_Maybe.Nothing) {
                return PSD3_Kernel_D3_Core.createManyBody({
                    strength: valueToNumber(fc.strength),
                    theta: fc.theta,
                    distanceMin: fc.distanceMin,
                    distanceMax: fc.distanceMax
                });
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 418, column 20 - line 431, column 8): " + [ fc.filter.constructor.name ]);
        };
        if (fc.forceType instanceof ForceCollide) {
            if (fc.radius instanceof Static) {
                return PSD3_Kernel_D3_Core.createCollide({
                    radius: fc.radius.value0,
                    strength: valueToNumber(fc.strength),
                    iterations: fc.iterations
                });
            };
            if (fc.radius instanceof Dynamic) {
                return PSD3_Kernel_D3_Core.createCollideDynamic({
                    radiusAccessor: fc.radius.value0,
                    strength: valueToNumber(fc.strength),
                    iterations: fc.iterations
                });
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 433, column 19 - line 443, column 8): " + [ fc.radius.constructor.name ]);
        };
        if (fc.forceType instanceof ForceLink) {
            return PSD3_Kernel_D3_Core.createLink({
                distance: valueToNumber(fc.distance),
                strength: valueToNumber(fc.strength),
                iterations: fc.iterations
            });
        };
        if (fc.forceType instanceof ForceCenter) {
            return PSD3_Kernel_D3_Core.createCenter({
                x: valueToNumber(fc.x),
                y: valueToNumber(fc.y),
                strength: valueToNumber(fc.strength)
            });
        };
        if (fc.forceType instanceof ForcePositionX) {
            if (fc.x instanceof Static) {
                return PSD3_Kernel_D3_Core.createForceX({
                    x: fc.x.value0,
                    strength: valueToNumber(fc.strength)
                });
            };
            if (fc.x instanceof Dynamic) {
                return PSD3_Kernel_D3_Core.createForceXDynamic({
                    xAccessor: fc.x.value0,
                    strength: valueToNumber(fc.strength)
                });
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 459, column 21 - line 467, column 8): " + [ fc.x.constructor.name ]);
        };
        if (fc.forceType instanceof ForcePositionY) {
            if (fc.y instanceof Static) {
                return PSD3_Kernel_D3_Core.createForceY({
                    y: fc.y.value0,
                    strength: valueToNumber(fc.strength)
                });
            };
            if (fc.y instanceof Dynamic) {
                return PSD3_Kernel_D3_Core.createForceYDynamic({
                    yAccessor: fc.y.value0,
                    strength: valueToNumber(fc.strength)
                });
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 469, column 21 - line 477, column 8): " + [ fc.y.constructor.name ]);
        };
        if (fc.forceType instanceof ForceRadial) {
            if (fc.filter instanceof Data_Maybe.Just) {
                return PSD3_Kernel_D3_Core.createRadialFiltered({
                    radius: valueToNumber(fc.radius),
                    x: valueToNumber(fc.x),
                    y: valueToNumber(fc.y),
                    strength: valueToNumber(fc.strength),
                    filter: fc.filter.value0
                });
            };
            if (fc.filter instanceof Data_Maybe.Nothing) {
                return PSD3_Kernel_D3_Core.createRadial({
                    radius: valueToNumber(fc.radius),
                    x: valueToNumber(fc.x),
                    y: valueToNumber(fc.y),
                    strength: valueToNumber(fc.strength)
                });
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 479, column 18 - line 492, column 8): " + [ fc.filter.constructor.name ]);
        };
        throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 417, column 31 - line 492, column 8): " + [ fc.forceType.constructor.name ]);
    })());
};
var computeNodeGUP = function (currentNodes) {
    return function (desiredNodes) {
        var desiredIds = fromFoldable1(map(function (v) {
            return v.id;
        })(desiredNodes));
        var exited = Data_Array.filter(function (n) {
            return !member(n.id)(desiredIds);
        })(currentNodes);
        var currentById = fromFoldable2(map(function (n) {
            return new Data_Tuple.Tuple(n.id, n);
        })(currentNodes));
        var processDesired = function (desired) {
            var v = lookup(desired.id)(currentById);
            if (v instanceof Data_Maybe.Nothing) {
                return {
                    node: desired,
                    isEnter: true
                };
            };
            if (v instanceof Data_Maybe.Just) {
                return {
                    node: mergeSimulationState(v.value0)(desired),
                    isEnter: false
                };
            };
            throw new Error("Failed pattern match at PSD3.Kernel.D3.Setup (line 602, column 7 - line 604, column 87): " + [ v.constructor.name ]);
        };
        var processed = map(processDesired)(desiredNodes);
        var entered = map(function (v) {
            return v.node;
        })(Data_Array.filter(function (v) {
            return v.isEnter;
        })(processed));
        var merged = map(function (v) {
            return v.node;
        })(processed);
        var updated = map(function (v) {
            return v.node;
        })(Data_Array.filter(function ($97) {
            return !(function (v) {
                return v.isEnter;
            })($97);
        })(processed));
        return {
            entered: entered,
            updated: updated,
            exited: exited,
            merged: merged
        };
    };
};
var computeLinkGUP = function (currentLinks) {
    return function (desiredLinks) {
        var linkKey = function (l) {
            return new Data_Tuple.Tuple(l.source, l.target);
        };
        var desiredKeys = fromFoldable3(map(linkKey)(desiredLinks));
        var currentKeys = fromFoldable3(map(linkKey)(currentLinks));
        var enterKeys = difference(desiredKeys)(currentKeys);
        var entered = Data_Array.filter(function (l) {
            return member1(linkKey(l))(enterKeys);
        })(desiredLinks);
        var exitKeys = difference(currentKeys)(desiredKeys);
        var exited = Data_Array.filter(function (l) {
            return member1(linkKey(l))(exitKeys);
        })(currentLinks);
        var updateKeys = intersection(desiredKeys)(currentKeys);
        var updated = Data_Array.filter(function (l) {
            return member1(linkKey(l))(updateKeys);
        })(desiredLinks);
        return {
            entered: entered,
            updated: updated,
            exited: exited
        };
    };
};
var collide = function (name) {
    return defaultForceConfig(name)(ForceCollide.value);
};
var center = function (name) {
    return defaultForceConfig(name)(ForceCenter.value);
};
var applySetup = function (setupConfig) {
    return function (sim) {
        return function __do() {
            var nodes = Effect_Ref.read(sim.nodes)();
            var links = Effect_Ref.read(sim.links)();
            var currentForces = Effect_Ref.read(sim.forces)();
            var desiredNames = fromFoldable4(map(function (v) {
                return v.name;
            })(setupConfig.forces));
            var currentNames = fromFoldable5(Data_Map.keys(currentForces));
            var toRemove = difference1(currentNames)(desiredNames);
            for_(toUnfoldable(toRemove))(function (name) {
                return Effect_Ref.modify_($$delete(name))(sim.forces);
            })();
            for_(setupConfig.forces)(function (fc) {
                return function __do() {
                    var handle = createForceHandle(fc)();
                    (function () {
                        if (fc.forceType instanceof ForceLink) {
                            return PSD3_Kernel_D3_Core.initializeLinkForce(handle)(nodes)(links)();
                        };
                        return PSD3_Kernel_D3_Core.initializeForce(handle)(nodes)();
                    })();
                    return Effect_Ref.modify_(insert(fc.name)(handle))(sim.forces)();
                };
            })();
            return Effect_Ref.write(setupConfig.params.alpha)(sim.alpha)();
        };
    };
};
var applySetupWithData = function (setupConfig) {
    return function (desiredNodes) {
        return function (desiredLinks) {
            return function (sim) {
                return function __do() {
                    var currentNodes = Effect_Ref.read(sim.nodes)();
                    var currentLinks = Effect_Ref.read(sim.links)();
                    var nodeResult = computeNodeGUP(currentNodes)(desiredNodes);
                    Effect_Ref.write(nodeResult.merged)(sim.nodes)();
                    var linkResult = computeLinkGUP(currentLinks)(desiredLinks);
                    Effect_Ref.write(desiredLinks)(sim.links)();
                    applySetup(setupConfig)(sim)();
                    return {
                        nodes: {
                            entered: nodeResult.entered,
                            updated: nodeResult.updated,
                            exited: nodeResult.exited
                        },
                        links: {
                            entered: linkResult.entered,
                            updated: linkResult.updated,
                            exited: linkResult.exited
                        }
                    };
                };
            };
        };
    };
};
var addForceToSim = function (fc) {
    return function (sim) {
        return function __do() {
            var nodes = Effect_Ref.read(sim.nodes)();
            var links = Effect_Ref.read(sim.links)();
            var handle = createForceHandle(fc)();
            (function () {
                if (fc.forceType instanceof ForceLink) {
                    return PSD3_Kernel_D3_Core.initializeLinkForce(handle)(nodes)(links)();
                };
                return PSD3_Kernel_D3_Core.initializeForce(handle)(nodes)();
            })();
            return Effect_Ref.modify_(insert(fc.name)(handle))(sim.forces)();
        };
    };
};
var addForce = function (fc) {
    return function (s) {
        return {
            name: s.name,
            params: s.params,
            forces: Data_Array.snoc(s.forces)(fc)
        };
    };
};
export {
    Static,
    Dynamic,
    $$static as static,
    dynamic,
    valueToNumber,
    forceName,
    manyBody,
    collide,
    link,
    center,
    positionX,
    positionY,
    radial,
    withStrength,
    withRadius,
    withX,
    withY,
    withDistance,
    withTheta,
    withIterations,
    withFilter,
    withDistanceMin,
    withDistanceMax,
    defaultParams,
    setup,
    setupWithParams,
    getForces,
    getParams,
    addForce,
    removeForce,
    updateForce,
    withAlpha,
    withAlphaDecay,
    withAlphaTarget,
    withAlphaMin,
    withVelocityDecay,
    applySetup,
    applySetupWithData,
    addForceToSim,
    removeForceFromSim,
    eqForceType
};
//# sourceMappingURL=index.js.map
