// Generated by purs version 0.15.15
import * as $foreign from "./foreign.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
import * as PSD3_ForceEngine_Core from "../PSD3.ForceEngine.Core/index.js";
import * as PSD3_ForceEngine_Types from "../PSD3.ForceEngine.Types/index.js";
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect.applicativeEffect);
var for_1 = /* #__PURE__ */ for_(Data_Foldable.foldableArray);
var toUnfoldable = /* #__PURE__ */ Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect.applicativeEffect);
var $$delete = /* #__PURE__ */ Data_Map_Internal["delete"](Data_Ord.ordString);
var when = /* #__PURE__ */ Control_Applicative.when(Effect.applicativeEffect);
var fromFoldable = /* #__PURE__ */ Data_Array.fromFoldable(Data_List_Types.foldableList);
var unless = /* #__PURE__ */ Control_Applicative.unless(Effect.applicativeEffect);
var for_2 = /* #__PURE__ */ for_(Data_Foldable.foldableMaybe);
var $$void = /* #__PURE__ */ Data_Functor["void"](Effect.functorEffect);
var insert = /* #__PURE__ */ Data_Map_Internal.insert(Data_Ord.ordString);
var updatePositionsInPlace = function (positions) {
    return function (sim) {
        return $foreign.updatePositionsInPlace_(positions)(sim.nodes);
    };
};
var updateGridYWithFn = function (fn) {
    return function (sim) {
        return $foreign.updateGridYWithFn_(fn)(sim.nodes);
    };
};
var updateGridXWithFn = function (fn) {
    return function (sim) {
        return $foreign.updateGridXWithFn_(fn)(sim.nodes);
    };
};
var updateGridPositionsInPlace = function (positions) {
    return function (sim) {
        return $foreign.updateGridPositionsInPlace_(positions)(sim.nodes);
    };
};
var unpinNodesInPlace = function (sim) {
    return $foreign.unpinNodesInPlace_(sim.nodes);
};
var stop = function (sim) {
    return function __do() {
        Effect_Ref.write(false)(sim.running)();
        var cancel = Effect_Ref.read(sim.cancelAnimation)();
        return cancel();
    };
};
var setNodes = function (nodes) {
    return function (sim) {
        return function __do() {
            PSD3_ForceEngine_Core.initializeNodes(nodes)();
            Effect_Ref.write(nodes)(sim.nodes)();
            var forces = Effect_Ref.read(sim.forces)();
            return for_1(toUnfoldable(forces))(function (v) {
                return function __do() {
                    PSD3_ForceEngine_Core.initializeForce(v.value1)(nodes)();
                    return Data_Unit.unit;
                };
            })();
        };
    };
};
var setLinks = function (links) {
    return function (sim) {
        return Effect_Ref.write(links)(sim.links);
    };
};
var setCallbacks = function (cbs) {
    return function (sim) {
        return {
            nodes: sim.nodes,
            links: sim.links,
            forces: sim.forces,
            alpha: sim.alpha,
            prevAlpha: sim.prevAlpha,
            config: sim.config,
            running: sim.running,
            cancelAnimation: sim.cancelAnimation,
            tickCallback: sim.tickCallback,
            callbacks: new Data_Maybe.Just(cbs)
        };
    };
};
var removeForce = function (name) {
    return function (sim) {
        return Effect_Ref.modify_($$delete(name))(sim.forces);
    };
};
var querySelectorElements = PSD3_ForceEngine_Core.querySelectorElements;
var pinNodesInPlace = function (sim) {
    return $foreign.pinNodesInPlace_(sim.nodes);
};
var pinNodesAtPositions = function (positions) {
    return function (sim) {
        return $foreign.pinNodesAtPositions_(positions)(sim.nodes);
    };
};
var onTick = function (callback) {
    return function (sim) {
        return Effect_Ref.write(callback)(sim.tickCallback);
    };
};
var isRunning = function (sim) {
    return Effect_Ref.read(sim.running);
};
var invokeTickCallback = function (sim) {
    if (sim.callbacks instanceof Data_Maybe.Nothing) {
        return pure(Data_Unit.unit);
    };
    if (sim.callbacks instanceof Data_Maybe.Just) {
        return function __do() {
            var callback = Effect_Ref.read(sim.callbacks.value0.onTick)();
            return callback();
        };
    };
    throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 514, column 26 - line 518, column 13): " + [ sim.callbacks.constructor.name ]);
};
var invokeStopCallback = function (sim) {
    if (sim.callbacks instanceof Data_Maybe.Nothing) {
        return pure(Data_Unit.unit);
    };
    if (sim.callbacks instanceof Data_Maybe.Just) {
        return function __do() {
            var callback = Effect_Ref.read(sim.callbacks.value0.onStop)();
            return callback();
        };
    };
    throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 504, column 26 - line 508, column 13): " + [ sim.callbacks.constructor.name ]);
};
var invokeStartCallback = function (sim) {
    if (sim.callbacks instanceof Data_Maybe.Nothing) {
        return pure(Data_Unit.unit);
    };
    if (sim.callbacks instanceof Data_Maybe.Just) {
        return function __do() {
            var callback = Effect_Ref.read(sim.callbacks.value0.onStart)();
            return callback();
        };
    };
    throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 494, column 27 - line 498, column 13): " + [ sim.callbacks.constructor.name ]);
};
var interpolatePositionsInPlace = function (startPos) {
    return function (targetPos) {
        return function (progress) {
            return function (sim) {
                return $foreign.interpolatePositionsInPlace_(startPos)(targetPos)(progress)(sim.nodes);
            };
        };
    };
};
var getNodes = function (sim) {
    return Effect_Ref.read(sim.nodes);
};
var getLinks = function (sim) {
    return Effect_Ref.read(sim.links);
};
var getCallbacks = function (sim) {
    return sim.callbacks;
};
var getAlpha = function (sim) {
    return Effect_Ref.read(sim.alpha);
};
var defaultConfig = /* #__PURE__ */ (function () {
    return {
        alphaMin: PSD3_ForceEngine_Types.defaultSimParams.alphaMin,
        alphaDecay: PSD3_ForceEngine_Types.defaultSimParams.alphaDecay,
        alphaTarget: PSD3_ForceEngine_Types.defaultSimParams.alphaTarget,
        velocityDecay: PSD3_ForceEngine_Types.defaultSimParams.velocityDecay
    };
})();
var createWithCallbacks = function (config) {
    return function (cbs) {
        return function __do() {
            var nodesRef = Effect_Ref["new"]([  ])();
            var linksRef = Effect_Ref["new"]([  ])();
            var forcesRef = Effect_Ref["new"](Data_Map_Internal.empty)();
            var alphaRef = Effect_Ref["new"](1.0)();
            var prevAlphaRef = Effect_Ref["new"](1.0)();
            var runningRef = Effect_Ref["new"](false)();
            var cancelRef = Effect_Ref["new"](pure(Data_Unit.unit))();
            var tickRef = Effect_Ref["new"](pure(Data_Unit.unit))();
            return {
                nodes: nodesRef,
                links: linksRef,
                forces: forcesRef,
                alpha: alphaRef,
                prevAlpha: prevAlphaRef,
                config: config,
                running: runningRef,
                cancelAnimation: cancelRef,
                tickCallback: tickRef,
                callbacks: new Data_Maybe.Just(cbs)
            };
        };
    };
};
var create = function (config) {
    return function __do() {
        var nodesRef = Effect_Ref["new"]([  ])();
        var linksRef = Effect_Ref["new"]([  ])();
        var forcesRef = Effect_Ref["new"](Data_Map_Internal.empty)();
        var alphaRef = Effect_Ref["new"](1.0)();
        var prevAlphaRef = Effect_Ref["new"](1.0)();
        var runningRef = Effect_Ref["new"](false)();
        var cancelRef = Effect_Ref["new"](pure(Data_Unit.unit))();
        var tickRef = Effect_Ref["new"](pure(Data_Unit.unit))();
        return {
            nodes: nodesRef,
            links: linksRef,
            forces: forcesRef,
            alpha: alphaRef,
            prevAlpha: prevAlphaRef,
            config: config,
            running: runningRef,
            cancelAnimation: cancelRef,
            tickCallback: tickRef,
            callbacks: Data_Maybe.Nothing.value
        };
    };
};
var clearForces = function (sim) {
    return Effect_Ref.write(Data_Map_Internal.empty)(sim.forces);
};
var checkAlphaThresholds = function (prevAlpha) {
    return function (newAlpha) {
        return function (sim) {
            var crossedThreshold = function (prev) {
                return function ($$new) {
                    return function (thresh) {
                        return prev > thresh && $$new <= thresh;
                    };
                };
            };
            var alphaThresholds = [ 0.5, 0.1, 1.0e-2 ];
            if (sim.callbacks instanceof Data_Maybe.Nothing) {
                return pure(Data_Unit.unit);
            };
            if (sim.callbacks instanceof Data_Maybe.Just) {
                return for_1(alphaThresholds)(function (threshold) {
                    return when(crossedThreshold(prevAlpha)(newAlpha)(threshold))(function __do() {
                        var callback = Effect_Ref.read(sim.callbacks.value0.onAlphaThreshold)();
                        return callback(newAlpha)();
                    });
                });
            };
            throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 527, column 47 - line 534, column 26): " + [ sim.callbacks.constructor.name ]);
        };
    };
};
var tick = function (sim) {
    return function __do() {
        var nodes = Effect_Ref.read(sim.nodes)();
        var forces = Effect_Ref.read(sim.forces)();
        var alpha = Effect_Ref.read(sim.alpha)();
        var prevAlpha = Effect_Ref.read(sim.prevAlpha)();
        var forceHandles = fromFoldable(Data_Map_Internal.values(forces));
        PSD3_ForceEngine_Core.applyForces(forceHandles)(alpha)();
        PSD3_ForceEngine_Core.integratePositions(nodes)(sim.config.velocityDecay)();
        var newAlpha = PSD3_ForceEngine_Core.decayAlpha(alpha)(sim.config.alphaMin)(sim.config.alphaDecay)(sim.config.alphaTarget);
        Effect_Ref.write(newAlpha)(sim.alpha)();
        Effect_Ref.write(alpha)(sim.prevAlpha)();
        var legacyCallback = Effect_Ref.read(sim.tickCallback)();
        legacyCallback();
        invokeTickCallback(sim)();
        checkAlphaThresholds(prevAlpha)(newAlpha)(sim)();
        return newAlpha;
    };
};
var start = function (sim) {
    return function __do() {
        var alreadyRunning = Effect_Ref.read(sim.running)();
        return unless(alreadyRunning)(function __do() {
            Effect_Ref.write(true)(sim.running)();
            invokeStartCallback(sim)();
            var cancel = PSD3_ForceEngine_Core.startAnimation(function (v) {
                return function __do() {
                    var running = Effect_Ref.read(sim.running)();
                    if (running) {
                        var newAlpha = tick(sim)();
                        var shouldContinue = newAlpha > 0.0;
                        unless(shouldContinue)(function __do() {
                            Effect_Ref.write(false)(sim.running)();
                            return invokeStopCallback(sim)();
                        })();
                        return shouldContinue;
                    };
                    return false;
                };
            })();
            return Effect_Ref.write(cancel)(sim.cancelAnimation)();
        })();
    };
};
var reheat = function (sim) {
    return function __do() {
        Effect_Ref.write(1.0)(sim.alpha)();
        var running = Effect_Ref.read(sim.running)();
        return unless(running)(start(sim))();
    };
};
var updateGridXYAndReinit = function (mXFn) {
    return function (mYFn) {
        return function (forceXHandle) {
            return function (mForceYHandle) {
                return function (sim) {
                    return function __do() {
                        for_2(mXFn)(function (xFn) {
                            return $foreign.updateGridXWithFn_(xFn)(sim.nodes);
                        })();
                        for_2(mYFn)(function (yFn) {
                            return $foreign.updateGridYWithFn_(yFn)(sim.nodes);
                        })();
                        var currentNodes = Effect_Ref.read(sim.nodes)();
                        PSD3_ForceEngine_Core.initializeForce(forceXHandle)(currentNodes)();
                        for_2(mForceYHandle)(function (forceYHandle) {
                            return $$void(PSD3_ForceEngine_Core.initializeForce(forceYHandle)(currentNodes));
                        })();
                        return reheat(sim)();
                    };
                };
            };
        };
    };
};
var attachPinningDrag = function (elements) {
    return function (sim) {
        return PSD3_ForceEngine_Core.attachPinningDrag(elements)(reheat(sim));
    };
};
var attachGroupDrag = function (elements) {
    return function (containerSelector) {
        return function (sim) {
            return PSD3_ForceEngine_Core.attachGroupDragWithReheat(elements)(containerSelector)(reheat(sim));
        };
    };
};
var attachDrag = function (elements) {
    return function (sim) {
        return PSD3_ForceEngine_Core.attachDragWithReheat(elements)(reheat(sim));
    };
};
var addForceHandle = function (name) {
    return function (handle) {
        return function (sim) {
            return Effect_Ref.modify_(insert(name)(handle))(sim.forces);
        };
    };
};
var addForce = function (spec) {
    return function (sim) {
        var forceName = function (v) {
            if (v instanceof PSD3_ForceEngine_Types.ManyBody) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.Collide) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.Link) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.Center) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.PositionX) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.PositionY) {
                return v.value0;
            };
            if (v instanceof PSD3_ForceEngine_Types.Radial) {
                return v.value0;
            };
            throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 335, column 15 - line 342, column 20): " + [ v.constructor.name ]);
        };
        return function __do() {
            var nodes = Effect_Ref.read(sim.nodes)();
            var links = Effect_Ref.read(sim.links)();
            var handle = (function () {
                if (spec instanceof PSD3_ForceEngine_Types.ManyBody) {
                    var h = PSD3_ForceEngine_Core.createManyBody(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.Collide) {
                    var h = PSD3_ForceEngine_Core.createCollide(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.Link) {
                    var h = PSD3_ForceEngine_Core.createLink(spec.value1);
                    return PSD3_ForceEngine_Core.initializeLinkForce(h)(nodes)(links)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.Center) {
                    var h = PSD3_ForceEngine_Core.createCenter(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.PositionX) {
                    var h = PSD3_ForceEngine_Core.createForceX(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.PositionY) {
                    var h = PSD3_ForceEngine_Core.createForceY(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                if (spec instanceof PSD3_ForceEngine_Types.Radial) {
                    var h = PSD3_ForceEngine_Core.createRadial(spec.value1);
                    return PSD3_ForceEngine_Core.initializeForce(h)(nodes)();
                };
                throw new Error("Failed pattern match at PSD3.ForceEngine.Simulation (line 302, column 13 - line 329, column 35): " + [ spec.constructor.name ]);
            })();
            var name = forceName(spec);
            return Effect_Ref.modify_(insert(name)(handle))(sim.forces)();
        };
    };
};
export {
    defaultConfig,
    create,
    createWithCallbacks,
    setNodes,
    setLinks,
    addForce,
    addForceHandle,
    removeForce,
    clearForces,
    start,
    stop,
    tick,
    reheat,
    onTick,
    setCallbacks,
    getCallbacks,
    isRunning,
    getAlpha,
    getNodes,
    getLinks,
    updatePositionsInPlace,
    interpolatePositionsInPlace,
    pinNodesInPlace,
    unpinNodesInPlace,
    pinNodesAtPositions,
    updateGridPositionsInPlace,
    updateGridXWithFn,
    updateGridYWithFn,
    updateGridXYAndReinit,
    attachDrag,
    attachGroupDrag,
    attachPinningDrag,
    querySelectorElements
};
//# sourceMappingURL=index.js.map
