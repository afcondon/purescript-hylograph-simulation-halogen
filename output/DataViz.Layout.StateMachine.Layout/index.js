// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordNumber);
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var max1 = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var truncate = function (n) {
    var truncatePos = function (x) {
        var go = function ($copy_acc) {
            return function ($copy_remaining) {
                var $tco_var_acc = $copy_acc;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(acc, remaining) {
                    if (remaining < 1.0) {
                        $tco_done = true;
                        return acc;
                    };
                    if (Data_Boolean.otherwise) {
                        $tco_var_acc = acc + 1 | 0;
                        $copy_remaining = remaining - 1.0;
                        return;
                    };
                    throw new Error("Failed pattern match at DataViz.Layout.StateMachine.Layout (line 318, column 5 - line 320, column 51): " + [ acc.constructor.name, remaining.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_acc, $copy_remaining);
                };
                return $tco_result;
            };
        };
        return go(0)(x);
    };
    var $27 = n >= 0.0;
    if ($27) {
        return truncatePos(n);
    };
    return -truncatePos(-n) | 0;
};
var selfLoopPath = function (config) {
    return function (layoutCenter) {
        return function (pos) {
            var loopRadius = config.selfLoopRadius * 0.5;
            var dy = pos.cy - layoutCenter.cy;
            var dx = pos.cx - layoutCenter.cx;
            var dist = Data_Number.sqrt(dx * dx + dy * dy);
            var outwardAngle = (function () {
                var $28 = dist > 0.0;
                if ($28) {
                    return Data_Number.atan2(dy)(dx);
                };
                return -Data_Number.pi / 2.0;
            })();
            var endAngle = outwardAngle + 0.6;
            var endX = pos.cx + pos.rx * Data_Number.cos(endAngle);
            var endY = pos.cy + pos.ry * Data_Number.sin(endAngle);
            var labelX = pos.cx + (pos.rx + loopRadius * 2.0 + 10.0) * Data_Number.cos(outwardAngle);
            var labelY = pos.cy + (pos.ry + loopRadius * 2.0 + 10.0) * Data_Number.sin(outwardAngle);
            var startAngle = outwardAngle - 0.6;
            var startX = pos.cx + pos.rx * Data_Number.cos(startAngle);
            var startY = pos.cy + pos.ry * Data_Number.sin(startAngle);
            var controlY = pos.cy + (pos.ry + loopRadius * 1.5) * Data_Number.sin(outwardAngle);
            var controlX = pos.cx + (pos.rx + loopRadius * 1.5) * Data_Number.cos(outwardAngle);
            var angle = endAngle - Data_Number.pi / 2.0;
            return {
                startX: startX,
                startY: startY,
                controlX: controlX,
                controlY: controlY,
                endX: endX,
                endY: endY,
                labelX: labelX,
                labelY: labelY,
                angle: angle,
                isSelfLoop: true
            };
        };
    };
};
var floor = function (n) {
    var i = truncate(n);
    var $29 = Data_Int.toNumber(i) > n;
    if ($29) {
        return i - 1 | 0;
    };
    return i;
};
var findStatePosition = function (states) {
    return function (id) {
        var v = Data_Array.filter(function (s) {
            return s.state.id === id;
        })(states);
        if (v.length === 1) {
            return new Data_Maybe.Just(v[0].position);
        };
        return Data_Maybe.Nothing.value;
    };
};
var defaultPath = {
    startX: 0.0,
    startY: 0.0,
    controlX: 0.0,
    controlY: 0.0,
    endX: 0.0,
    endY: 0.0,
    labelX: 0.0,
    labelY: 0.0,
    angle: 0.0,
    isSelfLoop: false
};
var defaultConfig = {
    stateRadiusX: 40.0,
    stateRadiusY: 25.0,
    layoutRadius: 150.0,
    margin: 80.0,
    selfLoopRadius: 50.0,
    arrowOffset: 3.0,
    initialArrowLength: 40.0
};
var countParallelTransitions = function (v) {
    return function (v1) {
        return 0;
    };
};
var computeLayoutCenter = function (states) {
    var sumY = foldl(function (acc) {
        return function (s) {
            return acc + s.position.cy;
        };
    })(0.0)(states);
    var sumX = foldl(function (acc) {
        return function (s) {
            return acc + s.position.cx;
        };
    })(0.0)(states);
    var n = Data_Int.toNumber(Data_Array.length(states));
    var $32 = n > 0.0;
    if ($32) {
        return {
            cx: sumX / n,
            cy: sumY / n
        };
    };
    return {
        cx: 0.0,
        cy: 0.0
    };
};
var computeInitialArrow = function (config) {
    return function (states) {
        var v = Data_Array.filter(function (s) {
            return s.state.isInitial;
        })(states);
        if (v.length === 1) {
            var x = v[0].position.cx - v[0].position.rx - config.initialArrowLength;
            return {
                x: x,
                y: v[0].position.cy,
                angle: 0.0
            };
        };
        return {
            x: 0.0,
            y: 0.0,
            angle: 0.0
        };
    };
};
var computeBounds = function (config) {
    return function (states) {
        var updateBounds = function (acc) {
            return function (s) {
                return {
                    minX: min(acc.minX)(s.position.cx - s.position.rx),
                    minY: min(acc.minY)(s.position.cy - s.position.ry),
                    maxX: max(acc.maxX)(s.position.cx + s.position.rx),
                    maxY: max(acc.maxY)(s.position.cy + s.position.ry)
                };
            };
        };
        var initial = {
            minX: 0.0,
            minY: 0.0,
            maxX: 0.0,
            maxY: 0.0
        };
        var bounds = foldl(updateBounds)(initial)(states);
        return {
            width: bounds.maxX + config.margin,
            height: bounds.maxY + config.margin
        };
    };
};
var circularLayout = function (config) {
    return function (states) {
        var positionState = function (cx) {
            return function (cy) {
                return function (step) {
                    return function (idx) {
                        return function (state) {
                            var angle = -Data_Number.pi / 2.0 + Data_Int.toNumber(idx) * step;
                            var position = {
                                cx: cx + config.layoutRadius * Data_Number.cos(angle),
                                cy: cy + config.layoutRadius * Data_Number.sin(angle),
                                rx: config.stateRadiusX,
                                ry: config.stateRadiusY
                            };
                            return {
                                state: state,
                                position: position
                            };
                        };
                    };
                };
            };
        };
        var n = Data_Array.length(states);
        var centerY = config.layoutRadius + config.margin;
        var centerX = config.layoutRadius + config.margin;
        var angleStep = (function () {
            var $35 = n > 0;
            if ($35) {
                return (2.0 * Data_Number.pi) / Data_Int.toNumber(n);
            };
            return 0.0;
        })();
        return Data_Array.mapWithIndex(positionState(centerX)(centerY)(angleStep))(states);
    };
};
var ceil = function (n) {
    var i = floor(n);
    var $36 = Data_Int.toNumber(i) < n;
    if ($36) {
        return i + 1 | 0;
    };
    return i;
};
var gridLayout = function (config) {
    return function (states) {
        var positionState = function (cols) {
            return function (cellW) {
                return function (cellH) {
                    return function (idx) {
                        return function (state) {
                            var row = div1(idx)(cols);
                            var col = mod(idx)(cols);
                            var position = {
                                cx: config.margin + Data_Int.toNumber(col) * cellW + cellW / 2.0,
                                cy: config.margin + Data_Int.toNumber(row) * cellH + cellH / 2.0,
                                rx: config.stateRadiusX,
                                ry: config.stateRadiusY
                            };
                            return {
                                state: state,
                                position: position
                            };
                        };
                    };
                };
            };
        };
        var n = Data_Array.length(states);
        var cols = max1(1)(ceil(Data_Number.sqrt(Data_Int.toNumber(n))));
        var cellWidth = 2.0 * config.stateRadiusX + 40.0;
        var cellHeight = 2.0 * config.stateRadiusY + 60.0;
        return Data_Array.mapWithIndex(positionState(cols)(cellWidth)(cellHeight))(states);
    };
};
var arcPath = function (config) {
    return function (from) {
        return function (to) {
            return function (_offset) {
                var dy = to.cy - from.cy;
                var dx = to.cx - from.cx;
                var dist = Data_Number.sqrt(dx * dx + dy * dy);
                var nx = (function () {
                    var $37 = dist > 0.0;
                    if ($37) {
                        return dx / dist;
                    };
                    return 1.0;
                })();
                var endX = to.cx - nx * (to.rx + config.arrowOffset);
                var startX = from.cx + nx * (from.rx + config.arrowOffset);
                var midX = (startX + endX) / 2.0;
                var ny = (function () {
                    var $38 = dist > 0.0;
                    if ($38) {
                        return dy / dist;
                    };
                    return 0.0;
                })();
                var endY = to.cy - ny * (to.ry + config.arrowOffset);
                var startY = from.cy + ny * (from.ry + config.arrowOffset);
                var midY = (startY + endY) / 2.0;
                var curveAmount = min(30.0)(dist * 0.15);
                var perpX = ny * curveAmount;
                var perpY = -nx * curveAmount;
                var controlY = midY + perpY;
                var labelY = controlY - 8.0;
                var tangentY = endY - controlY;
                var controlX = midX + perpX;
                var tangentX = endX - controlX;
                var angle = Data_Number.atan2(tangentY)(tangentX);
                return {
                    startX: startX,
                    startY: startY,
                    controlX: controlX,
                    controlY: controlY,
                    endX: endX,
                    endY: endY,
                    labelX: controlX,
                    labelY: labelY,
                    angle: angle,
                    isSelfLoop: false
                };
            };
        };
    };
};
var layoutTransition = function (config) {
    return function (states) {
        return function (transition) {
            var toPos = findStatePosition(states)(transition.to);
            var layoutCenter = computeLayoutCenter(states);
            var fromPos = findStatePosition(states)(transition.from);
            var path = (function () {
                if (fromPos instanceof Data_Maybe.Just && toPos instanceof Data_Maybe.Just) {
                    var $41 = transition.from === transition.to;
                    if ($41) {
                        return selfLoopPath(config)(layoutCenter)(fromPos.value0);
                    };
                    return arcPath(config)(fromPos.value0)(toPos.value0)(countParallelTransitions(states)(transition));
                };
                return defaultPath;
            })();
            return {
                transition: transition,
                path: path
            };
        };
    };
};
var layoutWithConfig = function (config) {
    return function (layoutFn) {
        return function (machine) {
            var layoutStates = layoutFn(config)(machine.states);
            var layoutTransitions = map(layoutTransition(config)(layoutStates))(machine.transitions);
            var initialArrow = computeInitialArrow(config)(layoutStates);
            var v = computeBounds(config)(layoutStates);
            return {
                states: layoutStates,
                transitions: layoutTransitions,
                width: v.width,
                height: v.height,
                initialArrow: initialArrow
            };
        };
    };
};
var layout = /* #__PURE__ */ layoutWithConfig(defaultConfig)(circularLayout);
export {
    layout,
    layoutWithConfig,
    defaultConfig,
    circularLayout,
    gridLayout
};
//# sourceMappingURL=index.js.map
