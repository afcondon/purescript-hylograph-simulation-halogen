// Generated by purs version 0.15.15
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as DataViz_Layout_Chord_Types from "../DataViz.Layout.Chord.Types/index.js";
var add = /* #__PURE__ */ Data_Semiring.add(Data_Semiring.semiringNumber);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var bind = /* #__PURE__ */ Control_Bind.bind(Data_Maybe.bindMaybe);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var emptyGroup = {
    index: 0,
    startAngle: 0.0,
    endAngle: 0.0,
    value: 0.0
};
var computeGroupAngles = function (startAngle) {
    return function (padAngle) {
        return function (availableAngle) {
            return function (grandTotal) {
                return function (rowSums) {
                    var initial = {
                        currentAngle: startAngle,
                        result: [  ]
                    };
                    var accumulate = function (v) {
                        return function (value) {
                            var extent = (value / grandTotal) * availableAngle;
                            var groupEnd = v.currentAngle + extent;
                            var nextAngle = groupEnd + padAngle;
                            return {
                                currentAngle: nextAngle,
                                result: Data_Array.snoc(v.result)(new Data_Tuple.Tuple(v.currentAngle, groupEnd))
                            };
                        };
                    };
                    return (Data_Array.foldl(accumulate)(initial)(rowSums)).result;
                };
            };
        };
    };
};
var buildChords = function (matrix) {
    return function (groups) {
        return function (availableAngle) {
            return function (grandTotal) {
                var n = Data_Array.length(groups);
                var initialOffsets = map(function (v) {
                    return v.startAngle;
                })(groups);
                var buildRow = function (state) {
                    return function (v) {
                        var sourceGroup = Data_Maybe.fromMaybe(emptyGroup)(Data_Array.index(groups)(v.value0));
                        var buildCell = function (cellState) {
                            return function (v1) {
                                var $23 = v1.value1 <= 0.0;
                                if ($23) {
                                    return cellState;
                                };
                                var targetValue = Data_Maybe.fromMaybe(0.0)(bind(Data_Array.index(matrix)(v1.value0))(function (v2) {
                                    return Data_Array.index(v2)(v.value0);
                                }));
                                var targetGroup = Data_Maybe.fromMaybe(emptyGroup)(Data_Array.index(groups)(v1.value0));
                                var targetStart = targetGroup.startAngle + (v1.value1 / (function () {
                                    var $24 = targetGroup.value === 0.0;
                                    if ($24) {
                                        return 1.0;
                                    };
                                    return targetGroup.value;
                                })()) * (targetGroup.endAngle - targetGroup.startAngle) * 0.5;
                                var targetExtent = (function () {
                                    var $25 = targetGroup.value === 0.0;
                                    if ($25) {
                                        return 0.0;
                                    };
                                    return (targetValue / targetGroup.value) * (targetGroup.endAngle - targetGroup.startAngle);
                                })();
                                var targetEnd = targetStart + targetExtent;
                                var sourceExtent = (function () {
                                    var $26 = sourceGroup.value === 0.0;
                                    if ($26) {
                                        return 0.0;
                                    };
                                    return (v1.value1 / sourceGroup.value) * (sourceGroup.endAngle - sourceGroup.startAngle);
                                })();
                                var sourceEnd = cellState.offset + sourceExtent;
                                var chord = {
                                    source: {
                                        index: v.value0,
                                        startAngle: cellState.offset,
                                        endAngle: sourceEnd,
                                        value: v1.value1
                                    },
                                    target: {
                                        index: v1.value0,
                                        startAngle: targetStart,
                                        endAngle: min(targetEnd)(targetGroup.endAngle),
                                        value: targetValue
                                    }
                                };
                                return {
                                    offset: sourceEnd,
                                    chords: Data_Array.snoc(cellState.chords)(chord)
                                };
                            };
                        };
                        var rowResult = Data_Array.foldl(buildCell)({
                            offset: sourceGroup.startAngle,
                            chords: state.chords
                        })(Data_Array.mapWithIndex(Data_Tuple.Tuple.create)(v.value1));
                        return {
                            offsets: state.offsets,
                            chords: rowResult.chords
                        };
                    };
                };
                var result = Data_Array.foldl(buildRow)({
                    offsets: initialOffsets,
                    chords: [  ]
                })(Data_Array.mapWithIndex(Data_Tuple.Tuple.create)(matrix));
                return result.chords;
            };
        };
    };
};
var layoutWithConfig = function (config) {
    return function (matrix) {
        var rowSums = map(Data_Array.foldl(add)(0.0))(matrix);
        var n = Data_Array.length(matrix);
        var totalPadding = config.padAngle * Data_Int.toNumber(n);
        var grandTotal = Data_Array.foldl(add)(0.0)(rowSums);
        var safeTotal = (function () {
            var $31 = grandTotal === 0.0;
            if ($31) {
                return 1.0;
            };
            return grandTotal;
        })();
        var availableAngle = config.endAngle - config.startAngle - totalPadding;
        var groupAngles = computeGroupAngles(config.startAngle)(config.padAngle)(availableAngle)(safeTotal)(rowSums);
        var groups = Data_Array.mapWithIndex(function (i) {
            return function (v) {
                return {
                    index: i,
                    startAngle: v.value0,
                    endAngle: v.value1,
                    value: Data_Maybe.fromMaybe(0.0)(Data_Array.index(rowSums)(i))
                };
            };
        })(groupAngles);
        var chords = buildChords(matrix)(groups)(availableAngle)(safeTotal);
        return {
            groups: groups,
            chords: chords
        };
    };
};
var layout = /* #__PURE__ */ layoutWithConfig(DataViz_Layout_Chord_Types.defaultConfig);
export {
    layout,
    layoutWithConfig
};
//# sourceMappingURL=index.js.map
