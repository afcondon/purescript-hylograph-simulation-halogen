// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
import * as Foreign_Object from "../Foreign.Object/index.js";
import * as PSD3_Kernel_D3_Core from "../PSD3.Kernel.D3.Core/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var fromFoldable = /* #__PURE__ */ Foreign_Object.fromFoldable(Data_Foldable.foldableArray);
var updateNodePosition = function (positions) {
    return function (node) {
        var v = Foreign_Object.lookup(show(node.id))(positions);
        if (v instanceof Data_Maybe.Just) {
            var $16 = {};
            for (var $17 in node) {
                if ({}.hasOwnProperty.call(node, $17)) {
                    $16[$17] = node[$17];
                };
            };
            $16.x = v.value0.x;
            $16.y = v.value0.y;
            return $16;
        };
        if (v instanceof Data_Maybe.Nothing) {
            return node;
        };
        throw new Error("Failed pattern match at PSD3.Kernel.D3.Adapter (line 116, column 3 - line 118, column 20): " + [ v.constructor.name ]);
    };
};
var updatePositions = function (nodesRef) {
    return function (positions) {
        return function __do() {
            var nodes = Effect_Ref.read(nodesRef)();
            var updatedNodes = map(updateNodePosition(positions))(nodes);
            return Effect_Ref.write(updatedNodes)(nodesRef)();
        };
    };
};
var interpolateNode = function (startPositions) {
    return function (targetPositions) {
        return function (progress) {
            return function (node) {
                var key = show(node.id);
                var newX = (function () {
                    var v = Foreign_Object.lookup(key)(targetPositions);
                    var v1 = Foreign_Object.lookup(key)(startPositions);
                    if (v1 instanceof Data_Maybe.Just && v instanceof Data_Maybe.Just) {
                        return v1.value0.x + (v.value0.x - v1.value0.x) * progress;
                    };
                    if (v instanceof Data_Maybe.Just) {
                        return v.value0.x;
                    };
                    if (v1 instanceof Data_Maybe.Just) {
                        return v1.value0.x;
                    };
                    return node.x;
                })();
                var newY = (function () {
                    var v = Foreign_Object.lookup(key)(targetPositions);
                    var v1 = Foreign_Object.lookup(key)(startPositions);
                    if (v1 instanceof Data_Maybe.Just && v instanceof Data_Maybe.Just) {
                        return v1.value0.y + (v.value0.y - v1.value0.y) * progress;
                    };
                    if (v instanceof Data_Maybe.Just) {
                        return v.value0.y;
                    };
                    if (v1 instanceof Data_Maybe.Just) {
                        return v1.value0.y;
                    };
                    return node.y;
                })();
                var $32 = {};
                for (var $33 in node) {
                    if ({}.hasOwnProperty.call(node, $33)) {
                        $32[$33] = node[$33];
                    };
                };
                $32.x = newX;
                $32.y = newY;
                return $32;
            };
        };
    };
};
var interpolatePositions = function (nodesRef) {
    return function (startPositions) {
        return function (targetPositions) {
            return function (progress) {
                return function __do() {
                    var nodes = Effect_Ref.read(nodesRef)();
                    var updatedNodes = map(interpolateNode(startPositions)(targetPositions)(progress))(nodes);
                    return Effect_Ref.write(updatedNodes)(nodesRef)();
                };
            };
        };
    };
};
var capturePositions = function (nodes) {
    return fromFoldable(map(function (n) {
        return new Data_Tuple.Tuple(show(n.id), {
            x: n.x,
            y: n.y
        });
    })(nodes));
};
var applyFirstMatchingRule = function (rules) {
    return function (node) {
        var v = Data_Array.find(function (rule) {
            return rule.select(node);
        })(rules);
        if (v instanceof Data_Maybe.Just) {
            return v.value0.apply(node);
        };
        if (v instanceof Data_Maybe.Nothing) {
            return node;
        };
        throw new Error("Failed pattern match at PSD3.Kernel.D3.Adapter (line 138, column 3 - line 140, column 20): " + [ v.constructor.name ]);
    };
};
var applyRulesInPlace = function (nodesRef) {
    return function (rules) {
        return function __do() {
            var nodes = Effect_Ref.read(nodesRef)();
            var updatedNodes = map(applyFirstMatchingRule(rules))(nodes);
            return Effect_Ref.write(updatedNodes)(nodesRef)();
        };
    };
};
var mkAdapter = function (components) {
    return {
        getNodes: Effect_Ref.read(components.nodesRef),
        capturePositions: capturePositions,
        interpolatePositions: interpolatePositions(components.nodesRef),
        updatePositions: updatePositions(components.nodesRef),
        applyRulesInPlace: applyRulesInPlace(components.nodesRef),
        reinitializeForces: components.reinitForcesFn,
        reheat: components.reheatFn
    };
};
export {
    mkAdapter
};
//# sourceMappingURL=index.js.map
