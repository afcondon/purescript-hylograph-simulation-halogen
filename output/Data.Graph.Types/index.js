// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Ordering from "../Data.Ordering/index.js";
import * as Data_Show from "../Data.Show/index.js";
var compare = /* #__PURE__ */ Data_Ord.compare(Data_Ord.ordString);
var mapFlipped = /* #__PURE__ */ Data_Functor.mapFlipped(Data_Maybe.functorMaybe);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var NodeId = function (x) {
    return x;
};
var EdgeId = function (x) {
    return x;
};
var Graph = function (x) {
    return x;
};
var showNodeId = {
    show: function (v) {
        return v;
    }
};
var show = /* #__PURE__ */ Data_Show.show(showNodeId);
var showEdgeId = {
    show: function (v) {
        return show(v.from) + (" \u2192 " + show(v.to));
    }
};
var nodes = function (v) {
    return v.nodeSet;
};
var nodePositions = function (v) {
    return v.positions;
};
var eqNodeId = {
    eq: function (x) {
        return function (y) {
            return x === y;
        };
    }
};
var eq1 = /* #__PURE__ */ Data_Eq.eq(eqNodeId);
var ordNodeId = {
    compare: function (x) {
        return function (y) {
            return compare(x)(y);
        };
    },
    Eq0: function () {
        return eqNodeId;
    }
};
var lookup = /* #__PURE__ */ Data_Map_Internal.lookup(ordNodeId);
var compare1 = /* #__PURE__ */ Data_Ord.compare(ordNodeId);
var alter = /* #__PURE__ */ Data_Map_Internal.alter(ordNodeId);
var neighbors = function (nodeId) {
    return function (v) {
        return Data_Maybe.fromMaybe([  ])(lookup(nodeId)(v.adjacency));
    };
};
var eqEdgeId = {
    eq: function (x) {
        return function (y) {
            return eq1(x.from)(y.from) && eq1(x.to)(y.to);
        };
    }
};
var ordEdgeId = {
    compare: function (x) {
        return function (y) {
            var v = compare1(x.from)(y.from);
            if (v instanceof Data_Ordering.LT) {
                return Data_Ordering.LT.value;
            };
            if (v instanceof Data_Ordering.GT) {
                return Data_Ordering.GT.value;
            };
            return compare1(x.to)(y.to);
        };
    },
    Eq0: function () {
        return eqEdgeId;
    }
};
var edges = function (v) {
    return v.edgeList;
};
var edgeWeight = function (from) {
    return function (to) {
        return function (graph) {
            return mapFlipped(Data_Array.find(function (n) {
                return eq1(n.neighbor)(to);
            })(neighbors(from)(graph)))(function (v) {
                return v.weight;
            });
        };
    };
};
var buildAdjacency = function (edgeList) {
    var addNeighbor = function (node) {
        return function (neighbor) {
            return function (m) {
                return alter((function () {
                    var $61 = Data_Array.cons(neighbor);
                    var $62 = Data_Maybe.fromMaybe([  ]);
                    return function ($63) {
                        return Data_Maybe.Just.create($61($62($63)));
                    };
                })())(node)(m);
            };
        };
    };
    var addEdge = function (acc) {
        return function (edge) {
            var fwd = {
                neighbor: edge.to,
                weight: edge.weight
            };
            var bwd = {
                neighbor: edge.from,
                weight: edge.weight
            };
            return addNeighbor(edge.to)(bwd)(addNeighbor(edge.from)(fwd)(acc));
        };
    };
    return Data_Array.foldl(addEdge)(Data_Map_Internal.empty)(edgeList);
};
var mkGraph = function (nodeSet) {
    return function (edgeList) {
        return {
            nodeSet: nodeSet,
            edgeList: edgeList,
            adjacency: buildAdjacency(edgeList),
            positions: Data_Map_Internal.empty
        };
    };
};
var updateWeight = function (from) {
    return function (to) {
        return function (newWeight) {
            return function (v) {
                var updateEdge = function (edge) {
                    if (eq1(edge.from)(from) && eq1(edge.to)(to) || eq1(edge.from)(to) && eq1(edge.to)(from)) {
                        return {
                            from: edge.from,
                            to: edge.to,
                            weight: newWeight
                        };
                    };
                    if (Data_Boolean.otherwise) {
                        return edge;
                    };
                    throw new Error("Failed pattern match at Data.Graph.Types (line 111, column 3 - line 114, column 23): " + [ edge.constructor.name ]);
                };
                return {
                    nodeSet: v.nodeSet,
                    positions: v.positions,
                    edgeList: map(updateEdge)(v.edgeList),
                    adjacency: buildAdjacency(map(updateEdge)(v.edgeList))
                };
            };
        };
    };
};
export {
    NodeId,
    EdgeId,
    Graph,
    mkGraph,
    nodes,
    edges,
    neighbors,
    edgeWeight,
    updateWeight,
    nodePositions,
    eqNodeId,
    ordNodeId,
    showNodeId,
    eqEdgeId,
    ordEdgeId,
    showEdgeId
};
//# sourceMappingURL=index.js.map
