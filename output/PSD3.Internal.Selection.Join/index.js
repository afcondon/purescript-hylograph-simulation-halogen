// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_FoldableWithIndex from "../Data.FoldableWithIndex/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
var unsafeIndex = /* #__PURE__ */ Data_Array.unsafeIndex();
var foldlWithIndex = /* #__PURE__ */ Data_FoldableWithIndex.foldlWithIndex(Data_FoldableWithIndex.foldableWithIndexArray);
var computeJoinWithKey = function (dictEq) {
    var eq = Data_Eq.eq(dictEq);
    return function (newData) {
        return function (oldBindings) {
            return function (keyFn) {
                var processNewDatum = function (newIndex) {
                    return function (state) {
                        return function (datum) {
                            var newKey = keyFn(datum);
                            var v = Data_Array.findIndex(function (v1) {
                                return eq(keyFn(v1.datum))(newKey);
                            })(state.remainingOld);
                            if (v instanceof Data_Maybe.Nothing) {
                                var enterBinding = {
                                    datum: datum,
                                    newIndex: newIndex
                                };
                                return {
                                    remainingOld: state.remainingOld,
                                    matchedIndices: state.matchedIndices,
                                    update: state.update,
                                    enter: Data_Array.cons(enterBinding)(state.enter)
                                };
                            };
                            if (v instanceof Data_Maybe.Just) {
                                var newRemaining = Data_Maybe.fromMaybe(state.remainingOld)(Data_Array.deleteAt(v.value0)(state.remainingOld));
                                var matched = unsafeIndex(state.remainingOld)(v.value0);
                                var updateBinding = {
                                    element: matched.element,
                                    oldDatum: datum,
                                    newDatum: datum,
                                    newIndex: newIndex
                                };
                                return {
                                    enter: state.enter,
                                    update: Data_Array.cons(updateBinding)(state.update),
                                    remainingOld: newRemaining,
                                    matchedIndices: Data_Array.cons(v.value0)(state.matchedIndices)
                                };
                            };
                            throw new Error("Failed pattern match at PSD3.Internal.Selection.Join (line 167, column 9 - line 189, column 18): " + [ v.constructor.name ]);
                        };
                    };
                };
                var matchResult = foldlWithIndex(processNewDatum)({
                    remainingOld: oldBindings,
                    enter: [  ],
                    update: [  ],
                    matchedIndices: [  ]
                })(newData);
                return {
                    enter: Data_Array.reverse(matchResult.enter),
                    update: Data_Array.reverse(matchResult.update),
                    exit: matchResult.remainingOld
                };
            };
        };
    };
};
var computeJoin = function (dictEq) {
    var eq = Data_Eq.eq(dictEq);
    return function (newData) {
        return function (oldBindings) {
            var processNewDatum = function (newIndex) {
                return function (state) {
                    return function (datum) {
                        var v = Data_Array.findIndex(function (v1) {
                            return eq(v1.datum)(datum);
                        })(state.remainingOld);
                        if (v instanceof Data_Maybe.Nothing) {
                            var enterBinding = {
                                datum: datum,
                                newIndex: newIndex
                            };
                            return {
                                remainingOld: state.remainingOld,
                                matchedIndices: state.matchedIndices,
                                update: state.update,
                                enter: Data_Array.cons(enterBinding)(state.enter)
                            };
                        };
                        if (v instanceof Data_Maybe.Just) {
                            var newRemaining = Data_Maybe.fromMaybe(state.remainingOld)(Data_Array.deleteAt(v.value0)(state.remainingOld));
                            var matched = unsafeIndex(state.remainingOld)(v.value0);
                            var updateBinding = {
                                element: matched.element,
                                oldDatum: datum,
                                newDatum: datum,
                                newIndex: newIndex
                            };
                            return {
                                enter: state.enter,
                                update: Data_Array.cons(updateBinding)(state.update),
                                remainingOld: newRemaining,
                                matchedIndices: Data_Array.cons(v.value0)(state.matchedIndices)
                            };
                        };
                        throw new Error("Failed pattern match at PSD3.Internal.Selection.Join (line 100, column 7 - line 122, column 16): " + [ v.constructor.name ]);
                    };
                };
            };
            var matchResult = foldlWithIndex(processNewDatum)({
                remainingOld: oldBindings,
                enter: [  ],
                update: [  ],
                matchedIndices: [  ]
            })(newData);
            return {
                enter: Data_Array.reverse(matchResult.enter),
                update: Data_Array.reverse(matchResult.update),
                exit: matchResult.remainingOld
            };
        };
    };
};
export {
    computeJoin,
    computeJoinWithKey
};
//# sourceMappingURL=index.js.map
