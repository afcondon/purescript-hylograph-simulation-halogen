// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Show from "../Data.Show/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var intercalate = /* #__PURE__ */ Data_Array.intercalate(Data_Monoid.monoidString);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var toCartesianPoint = function (v) {
    return {
        x: v.radius * Data_Number.cos(v.angle),
        y: v.radius * Data_Number.sin(v.angle)
    };
};
var lerp = function (a) {
    return function (b) {
        return function (t) {
            return a + (b - a) * t;
        };
    };
};
var buildCatmullRomCurves = function (points) {
    var v = Data_Array.length(points);
    if (v < 3) {
        return "";
    };
    var segments = Data_Array.mapWithIndex(function (i) {
        return function (v1) {
            var $40 = i === 0 || i >= (Data_Array.length(points) - 1 | 0);
            if ($40) {
                return Data_Maybe.Nothing.value;
            };
            var p3 = Data_Maybe.fromMaybe({
                x: 0.0,
                y: 0.0
            })(Data_Array.index(points)(min(Data_Array.length(points) - 1 | 0)(i + 2 | 0)));
            var p2 = Data_Maybe.fromMaybe({
                x: 0.0,
                y: 0.0
            })(Data_Array.index(points)(i + 1 | 0));
            var p1 = Data_Maybe.fromMaybe({
                x: 0.0,
                y: 0.0
            })(Data_Array.index(points)(i));
            var p0 = Data_Maybe.fromMaybe({
                x: 0.0,
                y: 0.0
            })(Data_Array.index(points)(max(0)(i - 1 | 0)));
            var cp2y = p2.y - (p3.y - p1.y) / 6.0;
            var cp2x = p2.x - (p3.x - p1.x) / 6.0;
            var cp1y = p1.y + (p2.y - p0.y) / 6.0;
            var cp1x = p1.x + (p2.x - p0.x) / 6.0;
            return new Data_Maybe.Just("C" + (show(cp1x) + ("," + (show(cp1y) + (" " + (show(cp2x) + ("," + (show(cp2y) + (" " + (show(p2.x) + ("," + show(p2.y))))))))))));
        };
    })(points);
    return intercalate("")(Data_Array.catMaybes(segments));
};
var drawCubicBSpline = function (points) {
    var v = Data_Array.length(points);
    if (v === 0) {
        return "";
    };
    if (v === 1) {
        var v1 = Data_Array.head(points);
        if (v1 instanceof Data_Maybe.Just) {
            return "M" + (show(v1.value0.x) + ("," + show(v1.value0.y)));
        };
        if (v1 instanceof Data_Maybe.Nothing) {
            return "";
        };
        throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 217, column 10 - line 219, column 20): " + [ v1.constructor.name ]);
    };
    if (v === 2) {
        var v1 = Data_Array.last(points);
        var v2 = Data_Array.head(points);
        if (v2 instanceof Data_Maybe.Just && v1 instanceof Data_Maybe.Just) {
            return "M" + (show(v2.value0.x) + ("," + (show(v2.value0.y) + ("L" + (show(v1.value0.x) + ("," + show(v1.value0.y)))))));
        };
        return "";
    };
    var v1 = Data_Array.head(points);
    if (v1 instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v1 instanceof Data_Maybe.Just) {
        var start = "M" + (show(v1.value0.x) + ("," + show(v1.value0.y)));
        var curves = buildCatmullRomCurves(points);
        return start + curves;
    };
    throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 229, column 7 - line 239, column 28): " + [ v1.constructor.name ]);
};
var buildBSplineCurves = function (prev) {
    return function (points) {
        var v = Data_Array.length(points);
        if (v === 0) {
            return "";
        };
        if (v === 1) {
            var v1 = Data_Array.head(points);
            if (v1 instanceof Data_Maybe.Just) {
                return "L" + (show(v1.value0.x) + ("," + show(v1.value0.y)));
            };
            if (v1 instanceof Data_Maybe.Nothing) {
                return "";
            };
            throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 163, column 10 - line 165, column 20): " + [ v1.constructor.name ]);
        };
        var result = foldl(function (acc) {
            return function (point) {
                var midY = (acc.prevPoint.y + point.y) / 2.0;
                var midX = (acc.prevPoint.x + point.x) / 2.0;
                var segment = "Q" + (show(acc.prevPoint.x) + ("," + (show(acc.prevPoint.y) + (" " + (show(midX) + ("," + show(midY)))))));
                return {
                    path: acc.path + segment,
                    prevPoint: point
                };
            };
        })({
            path: "",
            prevPoint: prev
        })(points);
        var finalSegment = (function () {
            var v1 = Data_Array.last(points);
            if (v1 instanceof Data_Maybe.Just) {
                return "Q" + (show(result.prevPoint.x) + ("," + (show(result.prevPoint.y) + (" " + (show(v1.value0.x) + ("," + show(v1.value0.y)))))));
            };
            if (v1 instanceof Data_Maybe.Nothing) {
                return "";
            };
            throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 192, column 24 - line 199, column 24): " + [ v1.constructor.name ]);
        })();
        return result.path + finalSegment;
    };
};
var drawBSpline = function (points) {
    var v = Data_Array.uncons(points);
    if (v instanceof Data_Maybe.Nothing) {
        return "";
    };
    if (v instanceof Data_Maybe.Just) {
        var v1 = Data_Array.uncons(v.value0.tail);
        if (v1 instanceof Data_Maybe.Nothing) {
            return "M" + (show(v.value0.head.x) + ("," + show(v.value0.head.y)));
        };
        if (v1 instanceof Data_Maybe.Just) {
            var $57 = Data_Array["null"](v1.value0.tail);
            if ($57) {
                return "M" + (show(v.value0.head.x) + ("," + (show(v.value0.head.y) + ("L" + (show(v1.value0.head.x) + ("," + show(v1.value0.head.y)))))));
            };
            var start = "M" + (show(v.value0.head.x) + ("," + show(v.value0.head.y)));
            var curves = buildBSplineCurves(v.value0.head)(Data_Array.cons(v1.value0.head)(v1.value0.tail));
            return start + curves;
        };
        throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 132, column 7 - line 155, column 30): " + [ v1.constructor.name ]);
    };
    throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 129, column 3 - line 155, column 30): " + [ v.constructor.name ]);
};
var beta = 0.85;
var applyBundleTension = function (tension) {
    return function (points) {
        var v = Data_Array.last(points);
        var v1 = Data_Array.head(points);
        if (v1 instanceof Data_Maybe.Just && v instanceof Data_Maybe.Just) {
            var n = Data_Array.length(points);
            return Data_Array.mapWithIndex(function (i) {
                return function (point) {
                    var t = Data_Int.toNumber(i) / Data_Int.toNumber(n - 1 | 0);
                    var straightY = lerp(v1.value0.y)(v.value0.y)(t);
                    var straightX = lerp(v1.value0.x)(v.value0.x)(t);
                    var bundledY = lerp(straightY)(point.y)(tension);
                    var bundledX = lerp(straightX)(point.x)(tension);
                    return {
                        x: bundledX,
                        y: bundledY
                    };
                };
            })(points);
        };
        return points;
    };
};
var bundlePath = function (tension) {
    return function (points) {
        var v = Data_Array.length(points);
        if (v === 0) {
            return "";
        };
        if (v === 1) {
            var v1 = Data_Array.head(points);
            if (v1 instanceof Data_Maybe.Just) {
                return "M" + (show(v1.value0.x) + ("," + show(v1.value0.y)));
            };
            if (v1 instanceof Data_Maybe.Nothing) {
                return "";
            };
            throw new Error("Failed pattern match at DataViz.Layout.Hierarchy.EdgeBundle.BundleCurve (line 46, column 10 - line 48, column 20): " + [ v1.constructor.name ]);
        };
        if (v === 2) {
            var v1 = Data_Array.last(points);
            var v2 = Data_Array.head(points);
            if (v2 instanceof Data_Maybe.Just && v1 instanceof Data_Maybe.Just) {
                return "M" + (show(v2.value0.x) + ("," + (show(v2.value0.y) + ("L" + (show(v1.value0.x) + ("," + show(v1.value0.y)))))));
            };
            return "";
        };
        var bundled = applyBundleTension(tension)(points);
        return drawBSpline(bundled);
    };
};
var bundlePathCartesian = function (tension) {
    return function (points) {
        return bundlePath(tension)(points);
    };
};
var bundlePathRadial = function (tension) {
    return function (radialPoints) {
        var cartesian = map(toCartesianPoint)(radialPoints);
        return bundlePath(tension)(cartesian);
    };
};
var bundlePathCubic = function (tension) {
    return function (points) {
        var bundled = applyBundleTension(tension)(points);
        return drawCubicBSpline(bundled);
    };
};
export {
    bundlePath,
    bundlePathRadial,
    bundlePathCartesian,
    beta
};
//# sourceMappingURL=index.js.map
